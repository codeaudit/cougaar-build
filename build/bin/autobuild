#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#  Copyright 2001 Defense Advanced Research Projects
#  Agency (DARPA) and ALPINE (a BBN Technologies (BBN) and
#  Raytheon Systems Company (RSC) Consortium).
#  This software to be used only in accordance with the
#  COUGAAR licence agreement.
# </copyright>

#
# build script driver - used to run the build script hands-off 
# periodically (eg. hourly, daily, whatever).
# This is the script which is actually used for nightlies and releases,
# so it is tuned to BBNT's use - other potential users will have to make
# the obvious changes.
#

# Note that the bootstrapping proceedure assumes that CVSROOT is already
# properly set so that the build module can be checked out directly.
#

# examples:
# build the head (normal hourly build):
#   autobuild
# build V7_2
#   autobuild -v -t V7_2 -d alp72.build


use Cwd;
use File::Copy;
use File::Path;
use File::Find;

require "getopts.pl";

$verbose = 1;
$auto = "auto";
$tag = "HEAD";
$data = "default.build";
$host = "eiger";

$ssh = "ssh -n";
$scp = "scp -B";

&Getopts('va:t:d:h');
if ($opt_h) {
  print STDERR "Usage: autobuild [args]\n";
  print STDERR "\t-v\tVerbose mode\n";
  print STDERR "\t-a name\tDirectory name instead of 'auto'\n";
  print STDERR "\t-t tag\tTag to use instead of 'HEAD'\n";
  print STDERR "\t-d file\tData file to use instead of 'default.build'\n";
  print STDERR "\t-h\tThis usage commend\n";
  exit(-1);
}

$verbose++ if $opt_v;
$auto = $opt_a if ($opt_a);
$tag = $opt_t if ($opt_t);
$data = $opt_d if ($opt_d);

if ($opt_t && !$opt_a) {
  $auto = $opt_t;
}

# handle signals
sub sighandler {
  local ($sig) = @_;
  print "Caught a SIG$sig -- exiting\n";
  exit(0);
}
$SIG{INT} = 'sighandler';
$SIG{QUIT} = 'sighandler';

# bootstrap the build process
$tmpdir = "/tmp/$auto-build.$$";
mysystem("rm -rf $tmpdir");
mkd($tmpdir);
mysystem("cd $tmpdir ; cvs -Q export -D now build/bin build/data");
$basedir = "$tmpdir/build";

# this is where build will build into
$builddir = "/tmp/$auto";


$buildscript = "$basedir/bin/build";
# if data has any pathname components, use it instead of relative to checked-out
# version
if ($data =~ /\//) {
  $builddata = $data;
} else {
  $builddata = "$basedir/data/$data";
}
$keep = 4;

# clean up any waxy yellow buildup
mysystem("rm -rf $builddir");
mkdir($builddir);

# start a fresh build
$rarg = "";
$rarg = "-r $tag" if (! ($tar eq "HEAD"));
mysystem("$buildscript -v $rarg -obuild.root=$builddir $builddata >/tmp/$auto.out");

# what did we build?
opendir D, $builddir;
@allfiles = grep !/^\./, readdir D;
closedir D;
$built = $allfiles[0];

# copy whatever is there to $host
ssh("$host mkdir -p $auto/$built");
scp("$builddir/$built/dist/* $host:$auto/$built");
ssh("$host cd $auto \\; rm -f latest \\; ln -s $built latest");

# leave only last n builds
open(B, "$ssh $host ls $auto|");
@alldirs = <B>;
close(B);

@alldirs = grep /[0-9]*/, @alldirs;
@alldirs = sort @alldirs;

# skip over keepers
$i=0;
while ($i < $keep && ($_= pop @alldirs)) {
  $i++;
}

while ( ($_ = pop @alldirs)) {
  chomp;
  ssh("$host rm -rf $auto/$_");
}

mysystem("rm -rf $tmpdir");

exit 0;


sub mysystem {
  local($command)= @_;

  print STDERR "$command\n" if ($verbose>1);
  if ($pretend) {
    return 0;
  }

  if ($pid = fork ) {
    # parent
    waitpid $pid, 0;
    local($rc)= $?;
    # signal decoding from Perl5 manual
    $rc &= 0xffff;
    if ($rc != 0) {
      $sawerror++;
      if ($rc == 0xff00) {
	print STDERR "Command failed: $command $!\n";
      } elsif ($rc > 0x80) {
	$rc >>= 8;
	print STDERR "Completed with exit status of $rc\n";
      } else {
	print STDERR "Ran with ";
	if ($rc &  0x80) {
	  $rc &= 0x80;
	  print STDERR "coredump from ";
	}
	print STDERR "signal $rc\n";
      }
    }
  } elsif (defined $pid) {
    # child
    exec $command;
    print STDERR "$command: $!\n";
    exit(-1);
  } else {
    die "Couldn't run @_\n";
  }
}

sub mkd {
  my($p) = @_;
  mkdir $p, 0777;
}

sub ssh {
  my($c) = @_;
  mysystem("$ssh $c");
}

sub scp {
  my($c) = @_;
  mysystem("$scp $c");
}
