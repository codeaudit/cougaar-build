#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#  Copyright 2001-2003 BBNT Solutions, LLC
#  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Cougaar Open Source License as published by
#  DARPA on the Cougaar Open Source Website (www.cougaar.org).
# 
#  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
#  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
#  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
#  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
#  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
#  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
#  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
#  PERFORMANCE OF THE COUGAAR SOFTWARE.
# </copyright>

#
# build script driver - used to run the build script hands-off 
# periodically (eg. hourly, daily, whatever).
# This is the script which is actually used for nightlies and releases,
# so it is tuned to BBNT's use - other potential users will have to make
# the obvious changes.
#

# Note that the bootstrapping proceedure assumes that CVSROOT is already
# properly set so that the build module can be checked out directly.
#

# examples:
# build the head (normal hourly build):
#   autobuild
# build V7_2
#   autobuild -v -t V7_2 -d alp72.build


use Cwd;
use File::Copy;
use File::Path;
use File::Find;

require "getopts.pl";

$verbose = 1;
$auto = "auto";
$tag = "HEAD";
$data = "default.build";
$host = "eiger.alpine.bbn.com";
$cleanup = 1;
$keep = 3;

$ssh = "ssh -n";
$scp = "scp -B";
$extraargs="";

&Getopts('vVm:a:t:d:hkT:H:po:n:j:C');
if ($opt_h) {
  print STDOUT "Usage: autobuild [args]\n";
  print STDOUT "\t-v\tVerbose mode\n";
  print STDOUT "\t-V\tVery Verbose mode (also prints error log)\n";
  print STDOUT "\t-a name\tDirectory name instead of 'auto'\n";
  print STDOUT "\t-t tag\tTag to use instead of 'HEAD'\n";
  print STDOUT "\t-C\tOnly clean\n";
  print STDOUT "\t-d file\tData file to use instead of 'default.build'\n";
  print STDOUT "\t-k\tDont clean up afterwards (leave leftovers)\n";
  print STDOUT "\t-T dir\tPut temporary files in dir/tag instead of /tmp/tag\n";
  print STDOUT "\t-H host\tPublish to host instead of \"$host\"\n";
  print STDOUT "\t-h\tThis usage commend\n";
  print STDOUT "\t-p\tTag is to be treated as a point-tag (avoid use of cvs export -D)\n";
  print STDOUT "\t-o string\tPass string as extra arguments to build\n";
  print STDOUT "\t-n N\tKeep the last N builds online (default is $keep).\n";
  print STDOUT "\t-j path\tSet java.home to path.\n";
  print STDOUT "\t-m address\tSend email to address if the build fails\n";
  exit(-1);
}

$host = $opt_H if $opt_H;
$cleanup=0 if $opt_k;
$onlyclean = $opt_C;
$tag = $opt_t if ($opt_t);
$extraargs = $opt_o if ($opt_o);
$javahome = $opt_j if ($opt_j);

$verbose++ if $opt_v;
$verbose=3 if $opt_V;
$auto = $opt_a if ($opt_a);
$data = $opt_d if ($opt_d);
$mailaddr = $opt_m if ($opt_m);

if ($onlyclean) {
  cleanRemote();
  exit 0;
}

#if ($opt_t && !$opt_a) {
#  $auto = $opt_t;
#}

if ($opt_T) {
  $tmp = $opt_T;
} else {
  $tmp = "/tmp";
}

&mkd($tmp);
$tmp = "$tmp/$tag";
&mkd($tmp);

$statusfile = "$tmp/STATUS";
$lockfile = "$tmp/LOCK";
acquireLock();
logMessage("Started");

sub acquireLock {
  if (open(LOCK, "<$lockfile")) {
    $pid = <LOCK>;
    close(LOCK);
    chop $pid;
    logMessage("Lockfile $lockfile is owned by process $pid - exiting.");
    mailreport("FAILED: could not acquire lock");
    die("Could not acquire lock $lockfile");
  }

  if (!open(LOCK, ">$lockfile")) {
    logMessage("Couldn't open lockfile $lockfile for write - something seriously wrong");
    mailreport("FAILED: could not acquire lock");
    die("Could not acquire lock $lockfile");
  }
  print LOCK "$$\n";
  close(LOCK);
}

sub releaseLock {
  if (! open(LOCK, "<$lockfile")) {
    logMessage("Couldn't read lockfile $lockfile - we'll assume it is ok");
    return;
  }
  $pid = <LOCK>;		# one line;
  close(LOCK);

  chop $pid;
  if (! ($pid eq $$)) {
    logMessage("Lock held by $pid instead of $$ - someone is probably losing");
    return;
  }
  unlink($lockfile);
}

# handle signals
sub sighandler {
  local ($sig) = @_;
  print "Caught a SIG$sig -- exiting\n";
  releaseLock();
  logMessage("build failed (signal $sig)");
  exit(0);
}
$SIG{INT} = 'sighandler';
$SIG{QUIT} = 'sighandler';

# bootstrap the build process
$tmpdir = "$tmp/$tag-build.$$";
mysystem("rm -rf $tmpdir");
mkd($tmpdir);
{
  my($rarg) = "-r $tag" if (! ($tag eq "HEAD"));
  $rarg .= " -D now" if (!$opt_p);
  mysystem("cd $tmpdir ; cvs -Q export $rarg build/bin build/data");
}
$basedir = "$tmpdir/build";

# this is where build will build into
$builddir = "$tmp/$tag";


$buildscript = "$basedir/bin/build";
# if data has any pathname components, use it instead of relative to checked-out
# version
if ($data =~ /\//) {
  $builddata = $data;
} else {
  $builddata = "$basedir/data/$data";
}
$keep = $opt_n if $opt_n;	# reset the keep value if we need to

# clean up any waxy yellow buildup
mysystem("rm -rf $builddir");
&mkd($builddir);

# let them know we're in progress
{
  my($ds) = datestr();
  ssh("$host mkdir -p $auto/$tag \\; rm -f $auto/$tag/STATUS \\; echo BUILD started at $ds \\> $auto/$tag/STATUS");
}

# start a fresh build
$rarg = "";
$rarg = "-r $tag" if (! ($tag eq "HEAD"));
if ($javahome) {
  $extaargs = "$extraargs -ojava.home=$javahome";
}
mysystem("$buildscript -v $rarg $extraargs -obuild.root=$builddir -otmp=$tmp $builddata >$tmp/$tag.out");

# what did we build?
opendir D, $builddir;
@allfiles = grep !/^\./, readdir D;
closedir D;
$built = $allfiles[0];

# could we build it?
$status = "UNKNOWN";
{
  open(R, "tail -1 $builddir/$built/dist/build.out|");
  my @lines;
  @lines = <R>;
  close(R);

  if ($verbose>1) {
    my($line);
    print STDOUT "\nBuild log:\n";
    foreach $line (@lines) {
      print STDOUT $line;
    }
  }

  my $line = $lines[0];
  if ( ($line =~ /SUCCEEDED/)) {
    $status = "SUCCEEDED";
  } elsif (($line =~ /FAILED/)) {
    $status = "FAILED";
  }
}

# parse the old status reports
@statusReports;
{
  if (!open(STAT, "<$statusfile")) {
    logMessage("Couldn't open status file $statusfile for reading - something seriously wrong");
  } else {
    while (<STAT>) {
      chop;
      push @statusReports, $_;
    }
    close(STAT);
  }
}

# record the status
{
  if (!open(STAT, ">>$statusfile")) {
    logMessage("Couldn't open status file $statusfile for write - something seriously wrong");
  } else {
    print STAT "$built\t$status\n";
    close(STAT);
  }
}

# output the error log for requested builds
printErrors() if ($verbose>2);

# send email if requested
if (! ($status eq "SUCCEEDED")) {
  mailreport($status);
}

# copy whatever is there to $host
ssh("$host mkdir -p $auto/$tag/$built");
scp("$builddir/$built/dist/* $host:$auto/$tag/$built");
ssh("$host cd $auto/$tag \\; rm -f latest \\; ln -s $built latest");

# leave only last n builds
cleanRemote();

{
  my($ds) = datestr();
  ssh("$host rm -f $auto/$tag/STATUS \\; echo BUILD $status finished at $ds \\> $auto/$tag/STATUS");
}


mysystem("rm -rf $tmpdir");
mysystem("rm -rf $builddir") if $cleanup;
releaseLock();
logMessage("Finished");

exit 0;


sub mysystem {
  local($command)= @_;

  print STDOUT "$command\n" if ($verbose>1);
  if ($pretend) {
    return 0;
  }

  if ($pid = fork ) {
    # parent
    waitpid $pid, 0;
    local($rc)= $?;
    # signal decoding from Perl5 manual
    $rc &= 0xffff;
    if ($rc != 0) {
      $sawerror++;
      if ($rc == 0xff00) {
	print STDOUT "Command failed: $command $!\n";
      } elsif ($rc > 0x80) {
	$rc >>= 8;
	print STDOUT "Completed with exit status of $rc\n";
      } else {
	print STDOUT "Ran with ";
	if ($rc &  0x80) {
	  $rc &= 0x80;
	  print STDOUT "coredump from ";
	}
	print STDOUT "signal $rc\n";
      }
    }
  } elsif (defined $pid) {
    # child
    exec $command;
    print STDOUT "$command: $!\n";
    exit(-1);
  } else {
    logMessage("Failed: Couldn't run @_");
    die "Couldn't run @_\n";
  }
}

sub mkd {
  my($p) = @_;
  mkdir $p, 0777;
}

sub ssh {
  my($c) = @_;
  mysystem("$ssh $c");
}

sub scp {
  my($c) = @_;
  mysystem("$scp $c");
}

sub datestr {
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  # build time for build directory name
  $mon="0$mon" if ($mon<10);
  $mday="0$mday" if ($mday<10);
  $hour="0$hour" if($hour<10);
  $yr=$yr-2000;
  $yr="0$yr" if ($yr<10);
  "$yr$mon$mday$hour$min$sec";
}

sub logMessage {
  local($s)=@_;
  print STDOUT "$s\n" if ($verbose>1);
  open(LOG, ">>$tmp/$tag.log");
  my ($d) = datestr();
  print LOG "$d\t$s\n";
  close(LOG);
}


sub cleanRemote {
  open(B, "$ssh $host ls $auto/$tag|");
  @alldirs = <B>;
  close(B);

  @alldirs = grep /^[0-9]*$/, @alldirs;
  @alldirs = sort @alldirs;

  my $lsucc;
  my $lfail;

  # scan, oldest first
  foreach $dir (@alldirs) {
    chomp $dir;
    my $status = checkRemoteStatus($dir);
    $status{$dir} = $status;
    $lsucc = $dir if ($status eq "SUCCEEDED");
    $lfail = $dir if ($status eq "FAILED");
    print STDOUT "Status of $dir = $status\n" if ($verbose>1);
  }

  # if we saw a success or failure, then we're watching complient builds
  if ($lsucc || $lfail) {
    my $sc = 0;
    my $fc = 0;
    ssh("$host cd $auto/$tag \\; rm -f latest_success latest_failure");
    foreach $dir (reverse @alldirs) {
      chomp $dir;
      my $status = $status{$dir};
      if ($status eq "SUCCEEDED") {
	$sc++;
	$fc = 100;		# don't keep any older failures!
	# first is latest
	if ($sc == 1) {
	  ssh("$host cd $auto/$tag \\; ln -s $dir latest_success");
	}
	if ($sc > 2) {
	  rrm($dir);
	}
      }
      if ($status eq "FAILED") {
	$fc++;
	if ($fc == 1) {
	  ssh("$host cd $auto/$tag \\; ln -s $dir latest_failure");
	}
	if ($fc > $keep) {
	  rrm($dir);
	}
      }
    }
  } else {
    # older-style builds: keep the most recent N builds

    # skip over keepers
    $i=0;
    while ($i <= $keep && ($_= pop @alldirs)) {
      $i++;
    }

    while ( ($_ = pop @alldirs)) {
      chomp;
      rrm($_);
    }
  }
}

sub rrm {
  my ($p) = @_;
  ssh("$host rm -rf $auto/$tag/$p");
}

sub checkRemoteStatus {
  my ($rd) = @_;

  print STDOUT "$ssh $host tail -1 $auto/$tag/$rd/build.out\n" if ($verbose>1);
  open(R, "$ssh $host tail -1 $auto/$tag/$rd/build.out|");
  my @lines;
  @lines = <R>;
  close(R);

  my $line = $lines[0];
  my $result = "UNKNOWN";
  if ( ($line =~ /SUCCEEDED/)) {
    $result = "SUCCEEDED";
  } elsif (($line =~ /FAILED/)) {
    $result = "FAILED";
  }
  $result;
}

sub printErrors {
  my($statfile)= "$builddir/$built/dist/errors.out";
  if (-r $statfile) {
    print STDOUT "\nError log $statfile:\n";
    open(R, "<$statfile");
    while (<R>) {
      print STDOUT $_;
    }
    close(R);
  }
}

sub mailreport {
  my ($report) = @_;
  if (! ($mailaddr eq "") ) {
    my($statfile)= "$builddir/$built/dist/errors.out";
    my($complaint) = "Build of $tag at $built $report";

    if (-r $statfile) {
      mysystem("/bin/mail -s \"$complaint\" $mailaddr <$statfile");
    } else {
      mysystem("/bin/mail -s \"$complaint\" $mailaddr < /dev/null");
    }
  }
}
