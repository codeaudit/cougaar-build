#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#  Copyright 2001-2002 BBNT Solutions, LLC
#  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Cougaar Open Source License as published by
#  DARPA on the Cougaar Open Source Website (www.cougaar.org).
# 
#  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
#  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
#  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
#  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
#  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
#  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
#  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
#  PERFORMANCE OF THE COUGAAR SOFTWARE.
# </copyright>

#
# build script driver - used to run the build script hands-off 
# periodically (eg. hourly, daily, whatever).
# This is the script which is actually used for nightlies and releases,
# so it is tuned to BBNT's use - other potential users will have to make
# the obvious changes.
#

# Note that the bootstrapping proceedure assumes that CVSROOT is already
# properly set so that the build module can be checked out directly.
#

# examples:
# build the head (normal hourly build):
#   autobuild
# build V7_2
#   autobuild -v -t V7_2 -d alp72.build


use Cwd;
use File::Copy;
use File::Path;
use File::Find;

require "getopts.pl";

$verbose = 1;
$auto = "auto";
$tag = "HEAD";
$data = "default.build";
$host = "eiger.alpine.bbn.com";
$cleanup = 1;
$keep = 3;

$ssh = "ssh -n";
$scp = "scp -B";
$extraargs="";

&Getopts('va:t:d:hkT:H:po:n:j:');
if ($opt_h) {
  print STDERR "Usage: autobuild [args]\n";
  print STDERR "\t-v\tVerbose mode\n";
  print STDERR "\t-a name\tDirectory name instead of 'auto'\n";
  print STDERR "\t-t tag\tTag to use instead of 'HEAD'\n";
  print STDERR "\t-d file\tData file to use instead of 'default.build'\n";
  print STDERR "\t-k\tDont clean up afterwards (leave leftovers)\n";
  print STDERR "\t-T dir\tPut temporary files in dir/tag instead of /tmp/tag\n";
  print STDERR "\t-H host\tPublish to host instead of \"$host\"\n";
  print STDERR "\t-h\tThis usage commend\n";
  print STDERR "\t-p\tTag is to be treated as a point-tag (avoid use of cvs export -D)\n";
  print STDERR "\t-o string\tPass string as extra arguments to build\n";
  print STDERR "\t-n N\tKeep the last N builds online (default is $keep).\n";
  print STDERR "\t-j path\tSet java.home to path.\n";
  exit(-1);
}

$host = $opt_H if $opt_H;
$cleanup=0 if $opt_k;
$tag = $opt_t if ($opt_t);
$extraargs = $opt_o if ($opt_o);
$javahome = $opt_j if ($opt_j);

$verbose++ if $opt_v;
$auto = $opt_a if ($opt_a);
$data = $opt_d if ($opt_d);

if ($opt_t && !$opt_a) {
  $auto = $opt_t;
}

if ($opt_T) {
  $tmp = $opt_T;
} else {
  $tmp = "/tmp";
}

&mkd($tmp);
$tmp = "$tmp/$tag";
&mkd($tmp);


$lockfile = "$tmp/LOCK";
acquireLock();
logMessage("Started");

sub acquireLock {
  if (open(LOCK, "<$lockfile")) {
    $pid = <LOCK>;
    close(LOCK);
    chop $pid;
    logMessage("Lockfile $lockfile is owned by process $pid - exiting.");
    die("Could not acquire lock $lockfile");
  }

  if (!open(LOCK, ">$lockfile")) {
    logMessage("Couldn't open lockfile $lockfile for write - something seriously wrong");
    die("Could not acquire lock $lockfile");
  }
  print LOCK "$$\n";
  close(LOCK);
}

sub releaseLock {
  if (! open(LOCK, "<$lockfile")) {
    logMessage("Couldn't read lockfile $lockfile - we'll assume it is ok");
    return;
  }
  $pid = <LOCK>;		# one line;
  close(LOCK);

  chop $pid;
  if (! ($pid eq $$)) {
    logMessage("Lock held by $pid instead of $$ - someone is probably losing");
    return;
  }
  unlink($lockfile);
}

# handle signals
sub sighandler {
  local ($sig) = @_;
  print "Caught a SIG$sig -- exiting\n";
  releaseLock();
  logMessage("build failed (signal $sig)");
  exit(0);
}
$SIG{INT} = 'sighandler';
$SIG{QUIT} = 'sighandler';

# bootstrap the build process
$tmpdir = "$tmp/$auto-build.$$";
mysystem("rm -rf $tmpdir");
mkd($tmpdir);
{
  my($rarg) = "-r $tag" if (! ($tag eq "HEAD"));
  $rarg .= " -D now" if (!$opt_p);
  mysystem("cd $tmpdir ; cvs -Q export $rarg build/bin build/data");
}
$basedir = "$tmpdir/build";

# this is where build will build into
$builddir = "$tmp/$auto";


$buildscript = "$basedir/bin/build";
# if data has any pathname components, use it instead of relative to checked-out
# version
if ($data =~ /\//) {
  $builddata = $data;
} else {
  $builddata = "$basedir/data/$data";
}
$keep = $opt_n if $opt_n;	# reset the keep value if we need to

# clean up any waxy yellow buildup
mysystem("rm -rf $builddir");
&mkd($builddir);

# start a fresh build
$rarg = "";
$rarg = "-r $tag" if (! ($tag eq "HEAD"));
if ($javahome) {
  $extaargs = "$extraargs -ojava.home=$javahome";
}
system("$buildscript -v $rarg $extraargs -obuild.root=$builddir -otmp=$tmp $builddata >$tmp/$auto.out");

# what did we build?
opendir D, $builddir;
@allfiles = grep !/^\./, readdir D;
closedir D;
$built = $allfiles[0];

# copy whatever is there to $host
ssh("$host mkdir -p $auto/$built");
scp("$builddir/$built/dist/* $host:$auto/$built");
ssh("$host cd $auto \\; rm -f latest \\; ln -s $built latest");

# leave only last n builds
cleanRemote();

mysystem("rm -rf $tmpdir");
mysystem("rm -rf $builddir") if $cleanup;
releaseLock();
logMessage("Finished");

exit 0;


sub mysystem {
  local($command)= @_;

  print STDERR "$command\n" if ($verbose>1);
  if ($pretend) {
    return 0;
  }

  if ($pid = fork ) {
    # parent
    waitpid $pid, 0;
    local($rc)= $?;
    # signal decoding from Perl5 manual
    $rc &= 0xffff;
    if ($rc != 0) {
      $sawerror++;
      if ($rc == 0xff00) {
	print STDERR "Command failed: $command $!\n";
      } elsif ($rc > 0x80) {
	$rc >>= 8;
	print STDERR "Completed with exit status of $rc\n";
      } else {
	print STDERR "Ran with ";
	if ($rc &  0x80) {
	  $rc &= 0x80;
	  print STDERR "coredump from ";
	}
	print STDERR "signal $rc\n";
      }
    }
  } elsif (defined $pid) {
    # child
    exec $command;
    print STDERR "$command: $!\n";
    exit(-1);
  } else {
    logMessage("Failed: Couldn't run @_");
    die "Couldn't run @_\n";
  }
}

sub mkd {
  my($p) = @_;
  mkdir $p, 0777;
}

sub ssh {
  my($c) = @_;
  mysystem("$ssh $c");
}

sub scp {
  my($c) = @_;
  mysystem("$scp $c");
}

sub datestr {
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  # build time for build directory name
  $mon="0$mon" if ($mon<10);
  $mday="0$mday" if ($mday<10);
  $hour="0$hour" if($hour<10);
  $yr=$yr-2000;
  $yr="0$yr" if ($yr<10);
  "$yr$mon$mday$hour$min$sec";
}

sub logMessage {
  local($s)=@_;
  open(LOG, ">>$tmp/$auto.log");
  my ($d) = datestr();
  print LOG "$d\t$s\n";
  close(LOG);
}


sub cleanRemote {
  open(B, "$ssh $host ls $auto|");
  @alldirs = <B>;
  close(B);

  @alldirs = grep /^[0-9]*$/, @alldirs;
  @alldirs = sort @alldirs;

  my $lsucc;
  my $lfail;

  # scan, oldest first
  foreach $dir (reverse @alldirs) {
    chomp $dir;
    my $status = checkRemoteStatus($dir);
    $status{$dir} = $status;
    $lsucc = $dir if ($status eq "SUCCEEDED");
    $lfail = $dir if ($status eq "FAILED");
  }

  # if we saw a success or failure, then we're watching complient builds
  if ($lsucc || $lfail) {

    # delete the last failure if there's been a more recent success
    if ($lsucc > $lfail) {
      undef $lfail;
    }

    my ($cmd) = "$host cd $auto \\; rm -f latest_success latest_failure";
    $cmd .= " \\; ln -s $lsucc latest_success" if ($lsucc);
    $cmd .= " \\; ln -s $lsucc latest_failure" if ($lfail);
    ssh($cmd);

    # delete everything but the marked last ones
    foreach $dir (@alldirs) {
      chomp $dir;
      if (! ($dir eq $lsucc ||
	     $dir eq $lfail)) {
	rrm($dir);
      }
    }

  } else {
    # older-style builds: keep the most recent N builds

    # skip over keepers
    $i=0;
    while ($i <= $keep && ($_= pop @alldirs)) {
      $i++;
    }

    while ( ($_ = pop @alldirs)) {
      chomp;
      rrm($_);
    }
  }
}

sub rrm {
  my ($p) = @_;
  ssh("$host rm -rf $auto/$p");
}

sub checkRemoteStatus {
  my ($rd) = @_;

  open(R, "$ssh $host tail -1 $auto/$rd/build.out|");
  my @lines;
  @lines = <R>;
  close(R);

  my $line = $lines[0];
  my $result = "UNKNOWN";
  if ( ($line =~ /SUCCEEDED/)) {
    $result = "SUCCEEDED";
  } elsif (($line =~ /FAILED/)) {
    $result = "FAILED";
  }
  $result;
}

