#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#  Copyright 2001 BBNT Solutions, LLC
#  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Cougaar Open Source License as published by
#  DARPA on the Cougaar Open Source Website (www.cougaar.org).
# 
#  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
#  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
#  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
#  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
#  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
#  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
#  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
#  PERFORMANCE OF THE COUGAAR SOFTWARE.
# </copyright>

# run a full release build

use Cwd;
use File::Copy;
use File::Path;
use File::Find;

$opt_file = "default.build";
@opt_overrides;

$verbose = 1;
$pointP = 0;
$isSigning = 1;

sub parse_args {
  while ($#ARGV>=0) {
    $_ = shift @ARGV;
    if ( /^-o(.+)/) {
      push @opt_overrides, $1;
    } elsif (/^-r/) {
      $opt_r = shift @ARGV;
    } elsif (/^-D/) {
      $opt_D = shift @ARGV;
    } elsif (/^-t/) {
      $tag = shift @ARGV;
    } elsif (/^-m/) {
      $opt_m = shift @ARGV;
    } elsif ( /^-(.+)/) {
      foreach $c (split //, $1) {
	if ($c eq "h") {
	  usage();
	} elsif ($c eq "v") {
	  $verbose++;
	} elsif ($c eq "q") {
	  $verbose--;
	} elsif ($c eq "n") {
	  $pretend = 1;
	  $verbose++;
	} elsif ($c eq "Q") {
	  $nodoc = 1;
	  #$isSigning = 0;
	} elsif ($c eq "S") {
	  $skip = 1;
	} elsif ($c eq "c") {
	  $checkoutP = 1;
	} elsif ($c eq "b") {
	  $branchP = 1;
	} elsif ($c eq "F") {
	  $forceP = 1;
	} elsif ($c eq "p") {
	  $pointP = 1;
	} elsif ($c eq "k") {
	  $isSigning = 0;
	} else {
	  usage();
	}
      }
    } else {
      $opt_file = $_;
      usage() if ($#ARGV!=-1);
    }
  }
}


sub usage {
  print STDERR <<EOF;
Usage: build [options] [ReleaseDescriptionFile]
	-S	Skip checkout, rebuild from last try
	-Q	Quick build (no documentation)
	-v	be verbose
	-q	be quiet
	-n	show what would be done, but dont do it.  Implies -v.
	-c	checkout cvs sources from head of tag rather than export from timestamp point
	-okey=value	set parameters on the command line
	-D date	Specify a repository date to build/tag relative to
	-r tag	Specify a repository tag to build/tag relative to
	-t name	Tag (with name) instead of building (also uses -r and -D)
	-b	When tagging, branch instead of simple tag
	-F	When tagging, Force the tag (move the tag if it previously existed)
	-m mod[,...]	Specify a module or modules to build instead of all.  The script
	        will figure out the right order and all dependencies.
        -p      Assume building from a point-tag rather than a branch (avoid use of -D)
	-k	Dont sign any jars

The default ReleaseDescriptionFile is "default.build".  If the file is not
found as specified, it will try to check from cvs using the current CVSROOT from
build/data/<ReleaseDescriptionFile> and use that.

More parameters of the sort found in a ReleaseDescriptionFile may be places in 
HOME/.cougaar-build-HOST.FOO.COM, HOME/.cougaar-build-HOST, or
HOME/.cougaar-build-system-specific (searched in exactly that order, first found
wins).

For signing of jar files to work, the following parameters should be set:
  default.keystore (defaults to sys.lib/signingCA.keystore)
  default.keystore.storepass (required)
  default.keystore.keypass (defaults to storepass)
  default.keystore.alias (defaults to privileged)
Per-module overrides are allowed (e.g. instead of default, list the module name).
Third-party jars are signed with the "sys" module information.
Keystore information (especially passwords) should be passed as "-o" options,
in a non-published build driver file or as values in HOME/.cougaar-build-system-specific
file.

Examples:
Standard verbose build of the HEAD:
	build -v default.build
Retroactively point-tag the repositories at a specific date:
	build  -D '7/31/2001 10:00:11' -t V8_3_0 default.build
Build blackjack (and all required parts):
	build -m blackjack default.build

Also, you can set things up so that cvs is not required for the build by:
  1. unpack (on symbolic link) the cougaar source and support 
    distributions (*-dev.zip, cougaar-support.zip) in the directory
	/tmp/cougaar/DATE/src
    where DATE is the build date in YYMMDDHHmmSS format.
    For instance, "9/6/2001 20:07:26" becomes "010906200726"
  2. run the following command:
	build -SQv -osys.lib=/tmp/cougaar/DATE/src/sys default.build
    the -osys.lib= specifies the location of the support libs.
The built jars will be placed in /tmp/cougaar/DATE/lib and the product
zip files in /tmp/cougaar/DATE/dist as usual.

Note:  This script will work on Windows and Unix/Linux machines.  On windows,
you will need to set cp.sep=; in the parameters file (or on the command line with a -o
argument).

EOF

  exit(1);
}

@modules;			# list of modules to build.
%moduleDone;			# has a given module been built?
@depstack;			# stack of module dependencies being considered.

%opts;
parse_args();
if (-e $opt_file) {
  parse_config($opt_file);
} else {
  my($of)="/tmp/$$.build";
  my($t) = $opt_r;
  $t = "HEAD" if ($t eq "");
  my($rarg);
  $rarg = "-r $t" if (! ($t eq "HEAD"));
  mysystem("cvs -Q co -p $rarg build/data/$opt_file>$of");
  parse_config($of);
  unlink($of);
}

sub mkd {
  my($p) = @_;
  mkdir $p, 0777 if (!$pretend);
}

use Sys::Hostname;

sub maybeLoadParams {
  my ($p) = @_;
  if ( -e $p )  {
    parse_config($p);
    return 1;
  } else {
    return 0;
  }
}

{
  local($host) = hostname();
  local($home) = $ENV{HOME};
  local($success) = 0;
  if ($host && -d $home) {
    my ($shost);
    if ($host =~ /^([^.]+)\./) {
      $shost = $1;
    }

    $success = maybeLoadParams("$home/.cougaar-build-$host") || 
      ($shost && maybeLoadParams("$home/.cougaar-build-$shost"));
  }
  maybeLoadParams("$home/.cougaar-build-system-specific") if (! $success);
}

# try to circumvent some VM problems
$ENV{J2SE_PREEMPTCLOSE}="1";	# see bug parade 4344135
# might consider doing a workaround for 4466587
# by detecting the bad cases and doing a limit call.

#$compiler_touse = "jikes";
$compiler_touse = "javac";
addopt("javac.command", "javac");
addopt("jikes.command", "jikes");
addopt("javac.arguments", "-J-Xmx128m -J-Xms128m");
addopt("default.javadoc.memory", "-J-Xmx256m -J-Xms128m");

#Classpath separator set from property, defaults to Unix version
$cpsep = opt("cp.sep", ":");

sub addopt {
  my ($key, $val) = @_;
  $opts{$key} = $val if (! exists $opts{$key});
}

$java_command = "java";
$compiler_touse = opt("compiler",$compiler_touse);
$java_command = opt("java.command", $java_command);
{
  local($foo) = opt("java");
  if ($foo) {
    $java_command = $foo;
    print "Warning: java property is set, but java.command is preferred";
  }
}

$java_home = opt("java.home");
if (! $java_home) {
  if ( $java_command =~ /^(.+)\/bin\/java$/ ) {
    $java_home = $1;
  } else {
    open(JAVA, "which java|");
    my $line = <JAVA>;
    close(JAVA);
    if ($line =~ /(.*)\/bin\/java/) {
      $java_home = $1;
    } else {
      die("Cannot figure out where java is installed: set java.home to avoid problems.");
    }
  }
}

$jar_command = jdkCommand(opt("jar.command", "jar"));
{
  my ($foo) = opt("javadoc");
  if ($foo) {
    print "Warning: Using javadoc property: should use javadoc.command and javadoc.arguments instead.";
    $javadoc_command = $foo;
  } else {
    $javadoc_command = jdkCommand(opt("javadoc.command", "javadoc"));
  }
}
$rmic_command = jdkCommand(opt("rmic.command", "rmic"));
$rmic_arguments = opt("rmic.arguments", "-g -v1.2");

$jarsigner_command = jdkCommand(opt("jarsigner.command", "jarsigner"));
$jarsigner_arguments = opt("jarsigner.arguments");

if ($opt_m) {
  @modules = compute_modules($opt_m);
  push @modules, "build" if (! member("build",@modules));
  my $foo = join(", ", @modules);
  print "Computed modules from $opt_m = \n\t$foo\n";
}

sub compute_modules {
  my ($modspec) = @_;
  local(%done);
  local(@acc);
  local(@stack);
  foreach $mod (split /\s*,\s*/, $modspec) {
    compute_modules1($mod) if (! $done{$mod});
  }
  return @acc;
}

sub compute_modules1 {
  my ($mod) = @_;
  return if ($done{$mod});
  if (member($mod,@stack)) {
    die "Fatal error: dependency loop: $mod in @acc\n";
  }
  push @stack, $mod;
  my ($foo) = opt("$mod.deps");
  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    if (! $done{$dep}) {
      compute_modules1($dep);
    }
  }
  pop @stack;
  $done{$mod}=1;
  push @acc, $mod;
}

{
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  $rdate="$mon/$mday/$yr $hour:$min:$sec";
  # build time for build directory name
  $mon="0$mon" if ($mon<10);
  $mday="0$mday" if ($mday<10);
  $hour="0$hour" if($hour<10);
  $yr=$yr-2000;
  $yr="0$yr" if ($yr<10);
  $bdate="$yr$mon$mday$hour$min$sec";
}


# repository tag for build
if ($opt_r) {
  $rtag = $opt_r;
} else {
  $rtag = opt("tag.default");
  if (! $rtag) {
    $rtag = "HEAD";
  }
}

# build time
$rdate = $opt_D if ($opt_D);

# root of the build directory tree
$build_root = opt("build.root");
$tmp = opt("tmp", "/tmp");
if (! $build_root) {
  my $foo = opt("product.name");
  die("Could not figure out build.root!\n") if (!$foo);
  $build_root = "$tmp/$foo";
}

if ($skip) {
  opendir D, $build_root;
  @alldirs = grep !/^\./, readdir D;
  closedir D;
  @alldirs = grep /[0-9]+/, @alldirs;
  @alldirs = sort @alldirs;
  @alldirs = reverse @alldirs;

  $bdate = $alldirs[0];
  print STDERR "Latest = $bdate\n";
}

# absolute path of directory we are building into
$build_dir = "$build_root/$bdate";

# record start time for later measurement
$start_time = time;


# subdir containing all the sources
$srcdir = "$build_dir/src";

$product = opt("product.name");

$latest_dir = "$build_root/latest";

if ($tag) {
  tag($tag);
  exit(0);
}

# create the build dirs
mkd "$build_root";
mkd $build_dir;
unlink "$latest_dir";
print "ln -s $build_dir $latest_dir\n" if $verbose;
symlink "$build_dir", "$latest_dir";
mkd $srcdir;
# libdir is where we store built jars
$libdir = "$build_dir/lib";
mkd $libdir;
# distdir is where we put end products
$distdir = "$build_dir/dist";
mkd $distdir;

chdir($distdir) || die("Couldn't chdir to $distdir");

# redirect streams to file
$errout = "$distdir/build.out";
open(SAVEOUT, ">&STDOUT");
open(SAVEERR, ">&STDERR");
#open(STDOUT, ">$errout");  # direct to file
open(STDOUT, "|tee $errout");  # tee to file
open(STDERR, ">&STDOUT");
select STDERR; $| = 1;		# unbuffered
select STDOUT; $| = 1;

print "Building $rtag at $rdate into $build_dir\n"  if $verbose;
print "Output is in $errout\n" if $verbose;


# just a copy of the enviroment variable (or maybe a command line option)
$sysclasspath;
@sysjars;
$syslib;
# skip the classpath evar and use the sys.lib param
{
  $syslib = opt("sys.lib");
  if ($syslib =~ /^module:(.+)/) {
    my($mod) = $1;
    $syslib = "$srcdir/$mod/lib";
    checkout_module($1, $srcdir) if (!$skip);
  }
  @sysjars = findbypattern($syslib, "\.(jar|zip)\$");
  $sysclasspath = join("$cpsep", @sysjars);
}


# classpath, possibly with rt.jar added for use by jikes
$augmented_classpath = $sysclasspath;
@rtjars;
if ($java_home) {
  if ( $compiler_touse =~ /jikes/ ) { # find rt.jar for jikes
#    $rtjar = "$java_home/jre/lib/rt.jar";
    @rtjars = ();
    my @exts = findbypattern("$java_home/jre/lib", "\.jar\$");
    push @rtjars, @exts;
    my $rtx = join("$cpsep",$rtjars);
    $augmented_classpath = "$augmented_classpath$cpsep$rtx";
  }
}

# Check out everything from CVS
&checkout if (!$skip);

# build the modules
&build;

# build unified source tree
if (! $opt_m || $nodoc) {
  &unify;
}

# build product.zip
&build_runtime;

# build product-support.zip
&build_3rdparty;

print "Building module unified\n";
# build unified javadoc
&build_javadoc("unified", "$product-api") if (!$nodoc);
print "Done building unified\n";

# add any dist extras
&add_dist;

# find and report on errors/warnings
&find_errors();

add_md5("$build_dir/dist");

sign_report();

# get end time and report on elapsed time
{
  reporttimes() if $verbose;
  $end_time = time;
  $delta = $end_time - $start_time;
  $min = int ($delta/60);
  $sec = $delta%60;
  print "Elapsed time = $min minutes $sec seconds\n" if $verbose;
}

exit(0);

#
# the pass routines
#

# moby checkout
sub checkout {
  print "\nStarting checkout\n" if $verbose;
  mkd $srcdir;
  chdir ($srcdir) || die ("Couldn't chdir to $build_dir");

  foreach $mod (@modules) {
    checkout_module($mod,$srcdir);
  }

  print "Checkout complete\n" if $verbose;
}

sub checkout_module {
  my ($mod, $dir) = @_;
  chdir ($dir) || die ("Couldn't chdir to $build_dir");
  print "\tchecking out $mod\n" if $verbose;

  my $rep = getCVSROOT($mod);
  my $cvsmod = opt("$mod.module","$mod");

  my $tag = opt("$mod.tag");
  $tag = $rtag if (!$tag);

  my $arg = "";
  $arg = "-Q";			# if ($verbose<=1);
  my $rarg="";
  # special case for HEAD - bogon.
  $rarg = "-r $tag" if (! ($tag eq "HEAD"));
  if ($checkoutP) {
    # hack to allow us to checkout a branch at a specific time
    $rarg .= " -D '$opt_D'" if ($opt_D && !pointP);
    # leave it in development mode
    mysystem ("cvs $arg -d '$rep' checkout $rarg -d $mod $cvsmod");
  } else {
    $rarg .= " -D '$rdate'" if ($rarg eq "" || !pointP);
    mysystem ("cvs $arg -d '$rep' export $rarg -d $mod $cvsmod");
  }
}


#
# moby build of modules
#

sub build {
  print "\nStarting building modules\n" if $verbose;

  build_module("build") || die("Compile of build module failed");

  foreach $mod (@modules) {
    build_module($mod) if (! ($mod eq "build"));
  }
  print "Finished building modules\n" if $verbose;
}

sub checkDeps {
  my ($mod) = @_;
  return if ($moduleDone{$mod}); # don't bother to check
  # check for loops
  if (member($mod, @depstack)) {
    die "Fatal Error: detected dependency loop: $mod @depstack\n";
  }
  push @depstack, $mod;		# add the current mod to the stack
  # build the submodules
  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    if (! $moduleDone{$dep}) {
      build_module($dep);
    }
  }
  pop @depstack;		# pop the current mod from the stack
}

sub build_module_src {
  # $mod is the actual module (e.g. key to opt($mod))
  # $mysrc is the src to build
  # $jname is the name of the jarfile (without .jar) to build the sources into
  my ($mod, $mysrc, $jname, $extrajars, $pass)= @_;

  my $builtjar = 0;
  my $tmplib = "$tmp/build-lib$$";

  my $nojar = $pass;
  my $examples_p = ($pass eq "examples");
  my $junit_p = ($pass eq "junit");

  $extrajars = "$extrajars$cpsep$syslib/junit.jar" if ($junit_p);

  if (-d $mysrc) {
    print "Compiling $jname sources:\n" if $verbose;
    mysystem("rm -rf $tmplib");
    mkd $tmplib;

    if (compile_dir($mod, $mysrc, $tmplib, $extrajars) && (! $nojar)) {
      print "Preparing jar for $jname\n" if $verbose;
      chdir ($tmplib);
      jar("$product/$jname runtime", $tmplib, $libdir, $jname, "$mysrc/manifest.mf");
      $builtjar = 1;
    }
    if ($junit_p) {
      print "Running $jname regression tests:\n" if $verbose;
      junit($mod, $tmplib, $extrajars);
    }
    # clean up
    chdir ($mysrc);
    mysystem("rm -rf $tmplib");
  }
  return $builtjar;
}


sub compute_path {
  my ($base,$type,$pext) = @_;
  my $tmp = "$base/$type";
  $tmp = "$tmp/$pext" if $pext;
  return $tmp;
}

sub build_module_main {
  my ($mod, $mypath, $pext) = @_;

  my $jname = $mod;
  $jname = "${jname}_$pext" if $pext;

  my $mysrc = &compute_path($mypath, "src", $pext);
  my $builtjar = &build_module_src($mod,$mysrc,$jname);
  my $extrajars = "$libdir/$jname.jar";

  {
    my $myex = &compute_path($mypath, "examples", $pext);
    if ( -d "$myex/src") {
      print "Compiling $jname examples src:\n" if $verbose;
      &build_module_src($mod,"$myex/src","${jname}_examples",$extrajars,"examples");
    } elsif ( -d $myex) {
      print "Compiling $jname examples:\n" if $verbose;
      &build_module_src($mod,$myex,"${jname}_examples",$extrajars,"examples");
    }
  }

  {
    my $mytest = &compute_path($mypath, "test", $pext);
    if ( -d "$mytest/src") {
      print "Compiling $jname test src:\n" if $verbose;
      &build_module_src($mod,"$mytest/src","${jname}_test",$extrajars,"test");
    } elsif ( -d $mytest) {
      print "Compiling $jname test:\n" if $verbose;
      &build_module_src($mod,$mytest,"${jname}_test",$extrajars,"test");
    }
  }

  {
    my $myreg = &compute_path($mypath, "regress", $pext);
    if (-d $myreg) {
      print "Compiling $jname regression tests:\n" if $verbose;
      &build_module_src($mod,$myreg,"${jname}_regress",$extrajars,"junit");
    }
  }

  # sign only after doing examples and regress
  sign_jar("$libdir/$jname.jar", $mod) if ($builtjar);

  return $builtjar;
}

sub build_module {
  my ($mod) = @_;
  return if ($moduleDone{$mod});

  checkDeps($mod);

  my $mymod = "$srcdir/$mod";
  print "\nBuilding module $mod\n";

  my $mysrc = "$mymod/src";
  my $tmplib = "$tmp/build-lib$$";
  my $builtjar = 0;

  # deal with splits properly
  my @splits = &opt("$mod.split");
  my $split_p = ($#splits >= 0);
  if ($split_p) {
    foreach $split (@splits) {
      &build_module_main($mod, $mymod, $split);
    }
  } else {
    $builtjar = &build_module_main($mod,$mymod,"");
  }

  # now create the product-module.zip file
  if (isPublic($mod)) {
    my $tmpdir = "$tmp/build-$mod.$$";
    mkd $tmpdir;
    my $tmpdist = "$tmpdir/$mod";
    mkd "$tmpdist";

    chdir "$srcdir/$mod";

    my $make_zip = 0;		# should we emit a zipfile?
    my $standalone_p = opt("$mod.standalone");

    my $pkg_name;
    if ( $standalone_p) {
      $pkg_name = "$mod";
    } else {
      $pkg_name = "$mod-dev";
    }

    if ($standalone_p && $split_p) {
      # make install some jars in the dist package
      my $tlib = "$tmpdist/lib";
      mkd $tlib;
      foreach $split (@splits) {
	my $pjar = "$libdir/${mod}_$split.jar";
	my $djar = "$tlib/${split}.jar";
	if (-e $pjar) {
	  &cp($pjar,$djar);
	  $make_zip++;
	}
      }
    }

    # bin,data,configs are now shipped as runtime parts.
    # Ship "dev" as a hack location for non-java and codegen source
    # placeholder.
    my @shipped_subdirs = ( "src", "examples", "regress", "dev" );
    my @maybe_subdirs = @shipped_subdirs;
    my @subdirs = ();
    my @runtime_subdirs = ("bin", "data", "configs", "doc");
    @maybe_subdirs = (@maybe_subdirs,@runtime_subdirs) if ($standalone_p);

    foreach $sub (@maybe_subdirs) {
      if (-d "$srcdir/$mod/$sub") {
	push @subdirs, $sub ;
      }
    }

    my $subdirs = join(" ", @subdirs);
    if ($subdirs) {
      $make_zip = 1;		# something to emit
      mysystem("tar cf - $subdirs | (cd $tmpdist; tar xf -)");

      # only do javadoc if it is not part of the unified build, and not split
      if ((! $split_p) && (! isUnified($mod))) {
	mkd "$tmpdist/doc";
	mkd "$tmpdist/doc/api";
	javadoc($mod, $mysrc, "$tmpdist/doc/api") if (!$nodoc);
      }

    }

    zip("$product $module", $tmpdir, $distdir, $pkg_name) if $make_zip;

    chdir($mymod);
    mysystem("rm -rf $tmpdir");
  }

  print "Done building $mod\n";
  $moduleDone{$mod}=1;
  return 1;
}


# try to find exactly the set of jars needed based on dependencies, etc
# if second arg!=0, will include .extras
sub get_classpath {
  local($mod,$xp) = @_;

  if ($mod eq "unified") {
    return get_unified_classpath();
  }
  # previously built jars
  my @buildjars = findbypattern($libdir, "\.jar\$");

  # current module's lib jars
  my @libjars = findbypattern("$srcdir/$mod/lib", "\.(jar|zip)\$");

  # add tools
  my @tooljars;
  if (-e "$java_home/lib/tools.jar") {
    @tooljars = ("$java_home/lib/tools.jar");
  }
  #put them together - module jars never take precedence
  my @alljars = (@buildjars, @sysjars, @libjars, @tooljars);

  # check the libjars carefully just in case someone is doing something stupid.
  {
    my @goodjars = (@buildjars, @sysjars);
    foreach $loclib (@libjars) {
      if ( ($loclib =~ /([^\/]+)\.(zip|jar)/) ) {
	my $match = $1;
	my @goods = grep /$1\.(zip|jar)$/, @goodjars;
	if ($#goods>=0) {
	  my $rc = mysystem("cmp $loclib $goods[0]");
	  print STDERR "Warning: Module $mod specifies $match as:\n\t$loclib\nwhich is also in:\n\t@goods\n\tmodule-local version will be ignored!\n";
	  if ($rc) {
	    print STDERR "Warning: $loclib and $goods[0] actually differ!\n";
	  } else {
	    print STDERR "The good news is that the $loclib and $goods[0] are the same.\n" if $verbose;
	  }
	}
      }
    }
  }

  # fill this up with required jars
  my @cp;

  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    my $jar = findjar($dep, @alljars);
    if ($jar eq "") {
      print "Warning: could not find $dep module for $mod\n";
    } else {
      push @cp, $jar;
    }
  }
  foreach $dep (split /\s*,\s*/, opt("$mod.jars")) {
    my $jar = findjar($dep, @alljars);
    if ($jar eq "") {
      print "Warning: could not find $dep jar for $mod\n";
    } else {
      push @cp, $jar;
    }
  }

  if ($xp) {
    foreach $dep (split /\s*,\s*/, opt("$mod.extras")) {
      my $jar = findjar($dep, @alljars);
      if ($jar eq "") {
	print "Warning: could not find $dep runtime jar for $mod\n";
      } else {
	push @cp, $jar;
      }
    }
  }

  my @libs = (@cp, @rtjars);
  my $cp = join("$cpsep",@libs);
  return ".$cpsep$cp";
}

sub get_unified_classpath {
  my %member;
  my @cp;
  foreach $m (@modules) {
    if (isUnified($m)) {
      foreach $c (split(/$cpsep/,get_classpath($m))) {
	if (! ($member{$c})) {
	  $member{$c} = 1;
	  push @cp, $c;
	}
      }
    }
  }
  return join("$cpsep", @cp);
}

sub findjar {
  local($name, @jars) = @_;
  my $pat = "\/$name\.(jar|zip)\$";
  foreach $_ (@jars) {
    return $_ if (/$pat/);
  }
  "";
}

sub add_module_files {
  local ($mysrc, $tmplib) = @_;
  chdir $mysrc;
  my $files = join(" ", findbypattern(".", "\.(def|gif|jpg|png|html|htm)\$"));
  if (! $files eq "") {
    mysystem("tar cf - $files | (cd $tmplib ; tar xf -)");
  }
}


# find all .def files and run the code generators on them
sub generate_code {
  my ($src, $cp) = @_;
  my @defs = findbypattern($src, "\.def\$");
  my $n = $#defs+1;
  for (@defs) {
    rundef($_, $cp);
  }
}

# code generate a single .def file
sub rundef {
  my ($path, $cp)=@_;
  open(DEF, "<$path");
  local($line);
  $line = <DEF>;
  local($rc)= -1;
  # if the first line is ";!generate: ..." then we'll use
  # it to build the def.
  if ( ($line =~ /\!generate:\s*(.*)$/) ) {
    $command = $1;	 
    # first word is the generator class
    @words = split /\s/, $command;

    # dirpath is the directory where the def file is
    @dirpath = split /\//, $path;
    pop @dirpath;
    $dirpath = join "/",@dirpath;

    # figure out the package name
    $class = $words[0];
    @pkgp = split /\./, $class;
    $pkgp = join "/",@pkgp;

    #print "Running $class\n" if $verbose;
    $args = join " ", @words[1..$#words];
    chdir($dirpath);
    my ($dargs) = "-Drepository.tag='$rtag' -Drepository.time='$rdate'";
    if ($skip || $checkoutP) {
      $dargs .= " -Drepository.modified=true";
    }
    $rc = java("$libdir/build.jar$cpsep$cp", "$dargs $class $args $path");
  }
  close(DEF);
  return $rc;
}


#
# build the unified tree
#
sub unify {
  my $mod = "unified";
  my $mysrc = "$srcdir/$mod/src";

  print "\nBuilding unified sources\n" if $verbose;
  mkd "$srcdir/$mod";
  mkd "$mysrc";

  foreach $m (@modules) {
    my $standalone_p = opt("$m.standalone");
    if ($standalone_p) {
      print "Skipping standalone $mod\n" if $verbose;
      next;
    }
    print "Adding module $m sources\n" if $verbose;
    if (isUnified($m) && opt("$mod.javadoc",1)) {
      my $nbase = "$srcdir/$m";
      my $nsrc = "$nbase/src";
      chdir $nsrc;
      mysystem("tar cf - . | (cd $mysrc ; tar xf - )");
    }
  }
  print "Done building unified sources\n" if $verbose;
}

#
# build the runtime package
#
sub build_runtime {
  my $mod;
  my $tmpdir = "$tmp/runtime.$$";
  print "\nBuilding runtime dist\n" if $verbose;
  mkd $tmpdir;
  my $tl = "$tmpdir/lib";
  mkd $tl;
  foreach $mod (@modules) {
    # skip standalone modules
    my $standalone_p = opt("${mod}.standalone");
    if ($standalone_p) {
      print "Skipping standalone $mod\n" if $verbose;
      next;
    }

    print "Adding $mod runtime\n" if $verbose;
    if (-e "$build_dir/lib/$mod.jar") {
      cp("$build_dir/lib/$mod.jar", "$tl");
    }
    my $moddir = "$srcdir/$mod";
    chdir $moddir;

    my @extras = opt("$mod.runtime");
    foreach $extra (@extras) {
      mysystem("tar cf - $extra | (cd $tmpdir; tar xf -)");
    }

    my @runtime_subdirs = ("bin", "data", "configs", "doc");
    foreach $rs (@runtime_subdirs) {
      if (member($rs, @extras)) { # skip top-level bits
	print "Skipping duplicate install of $mod/$rs\n" if $verbose;
      } else {
	if (-e "$moddir/$rs") {
	  chdir "$moddir";
	  mkd "$tmpdir/$mod";
	  mkd "$tmpdir/$mod/$rs";
	  mysystem("tar cf - $rs | (cd $tmpdir/$mod ; tar xf -)");
	}
      }
    }
  }

  chdir $tmpdir;
  zip("$product runtime", $tmpdir, $distdir, $product);
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building runtime dist\n" if $verbose;
}

# build the 3rdparty zip - mostly 3rd party jars.
sub build_3rdparty {
  my %member;
  my $mod;
  my $tmpdir = "$tmp/runtime.$$";
  print "\nBuilding 3rdparty dist\n" if $verbose;
  mkd $tmpdir;
  my $tl = "$tmpdir/sys";
  mkd $tl;

  # grab the modules (checked-in) jars
  foreach $mod (@modules) {
    my @libjars = findbypattern("$srcdir/$mod/lib", "\.(jar|zip)\$");
    my @alljars = (@sysjars, @libjars);	# prefer sysjars

    my @deps = ((split /\s*,\s*/, opt("$mod.jars")),
		(split /\s*,\s*/, opt("$mod.extras")));
    foreach $dep (@deps) {
      my $jar = findjar($dep, @alljars);
      if (!$jar) {
	next if ($dep eq "tools"); # skip tools (and other java standard ones, even if required)
	my $foo = join("$cpsep",@alljars);
	print STDERR "Warning: could not find $dep in $foo\n";
      }
      if ($jar && ! ($member{$dep})) {
	$member{$dep} = 1;
	cp($jar, $tl);
	if ($jar =~ /\/([^\/]+\.(zip|jar))$/) {
	  my ($tail) = $1;
	  sign_jar("$tl/$tail", "sys");
	}
      }
    }
  }

  if (-e "$syslib/index.html") {
    cp("$syslib/index.html","$tl/index.html");
  }

  chdir $tmpdir;
  zip("$product thirdparty jars", $tmpdir, $distdir, "$product-support");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building 3rdparty dist\n" if $verbose;
}

sub build_javadoc {
  local($mod,$dest)=@_;

  return if (!opt("$mod.javadoc",1));
  $dest = "$mod-api" if ($dest eq "");

  print "\nBuilding javadoc of $mod\n" if $verbose;

  # generate javadoc from unified source
  my $tmpdir = "$tmp/javadoc.$$";
  mkd $tmpdir;
  mkd "$tmpdir/doc";
  mkd "$tmpdir/doc/api";
  javadoc($mod, "$srcdir/$mod/src", "$tmpdir/doc/api");

  chdir $tmpdir;
  zip("$product javadoc apis", $tmpdir, $distdir, $dest);
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building javadoc for $mod\n" if $verbose;
}

sub add_dist {
  my $mod;
  print "\nCompleting dist package\n" if $verbose;
  foreach $mod (@modules) {
    my $dusts = opt("$mod.dist");
    if ($dusts) {
      my $moddir = "$srcdir/$mod";
      chdir $moddir;
      my @dust = split(/\s*,\s*/, $dusts);
      foreach $dust (@dust) {
	my $d = $moddir;
	my $f = $dust;
	if ($dust =~ /(.*)\/([^\/]*)/) {
	  $d = "$moddir/$1";
	  $f = $2;
	}
	mysystem("(cd $d; tar cf - $f) | (cd $distdir; tar xf -)");
      }
    }
  }
  print "Done adding to dist package\n" if $verbose;
}


sub javadoc {
  local($mod, $src,$dst) = @_;
  my %pmap;
  chdir "$src";
  # find all the directories with packages and convert 
  open(LIST, "find . -name '*.java' -print|");
  while (<LIST>) {
    my $line = $_;
    my $p = rindex($line, '/') - 2;
    if ($p > 0) {
      $line = substr($line, 2, $p);
      $line =~ s/\//\./g;
      $pmap{$line}=1;
    }
  }
  close(LIST);

  my $cp = cpWrap(get_classpath($mod));
  $ENV{CLASSPATH} = $cp;
  print STDERR "CLASSPATH = $cp\n" if ($verbose>1);

  my $lineargs = "";
  my($jdmemory) = gopt($mod, "javadoc.memory");
  $lineargs .= " $jdmemory" if ($jdmemory);

  my $argf = "$tmp/jdarg-$mod$$.txt";
  open(ARG, ">$argf");

  my($jdoptions) = gopt($mod, "javadoc.options");
  print ARG "$jdoptions\n" if ($jdoptions);


  if (opt("useDoclet", 1)) {
    my(@jddoclets) = gopt($mod, "javadoc.doclets");
    my(@jdtaglets) = gopt($mod, "javadoc.taglets");
    if ($#jddoclets>=0) {
      print ARG "-docletpath $libdir/build.jar\n";
      foreach $doclet (@jddoclets) {
	print ARG "-doclet $doclet\n";
      }
    }
    if ($#jdtaglets>=0) {
      print ARG "-tagletpath $libdir/build.jar\n";
      foreach $taglet (@jdtaglets) {
	print ARG "-taglet $taglet\n";
      }
    }
  }
  print ARG "-d $dst\n";
  print ARG "-sourcepath .\n";

  foreach $p (sort keys %pmap) {
    print ARG "$p\n";
  }

  close(ARG);

  my $javadoc_arguments = gopt($mod, "javadoc.arguments");
  $lineargs .= " $javadoc_arguments" if $javadoc_arguments;
  my ($time0) = time;
  mysystem("$javadoc_command $lineargs \@$argf");
  my ($time1) = time;
  addtime("javadoc",$time1-$time0);
  unlink($argf);
  undef $ENV{CLASSPATH};
}

# zip up a directory, adding appropriate comments, sums, etc.
sub zip {
  local($comment, $dir, $destdir, $destfile) = @_;
  chdir $dir;
  my ($dest) = "$destdir/$destfile.zip";
  add_info($comment, $dir, $destfile);
  mysystem("zip -qr $dest *");
}

sub jar {
  local($comment, $dir, $destdir, $destfile, $mf) = @_;
  chdir $dir;
  add_info($comment, $dir, $destfile);
  my ($dest) = "$destdir/$destfile.jar";
  if (-r $mf) {
    mysystem("$jar_command cmf $mf $dest *");
  } else {
    mysystem("$jar_command cf $dest *");
  }
}

sub add_info {
  local($comment, $dir, $destfile) = @_;
  my($mandir) = "$dir/Manifest";
  mkd($mandir);
  open(OUT, ">$mandir/$destfile.version");
  print OUT "COMMENT = $comment\n";
  print OUT "REPOSITORY_TAG = $rtag\n";
  print OUT "REPOSITORY_TIME = $rdate\n";
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  my $d ="$mon/$mday/$yr $hour:$min:$sec";
  print OUT "ARCHIVE_TIME = $d\n";
  close OUT;
}

sub add_md5 {
  local($dir) = @_;
  chdir($dir);
  my @archives = findbypattern(".", "\.(jar|zip|tar|tgz)\$");
  my @list;
  foreach $a (@archives) {
    $a =~ s/^\.\///;
    push @list, $a;
  }
  my $list = join(" ", @list);
  mysystem("md5sum $list > md5sums.txt");
}

sub sign_report {
  my ($count) = $#signed + 1;
  if ($verbose>2) {
    if ($#signed_jars>=0) {
      print "Signed the following jars: \n";
      foreach $j (@signed_jars) {
	print "\t$j\n";
      }
    } else {
      print "Signed no jars\n";
    }
  } else {
    print "Signed $count jars\n";
  }
}

sub sign_jar {
  my($jar, $mod) = @_;
  if ($isSigning) {
    my($ks)= gopt($mod, "keystore", "$syslib/signingCA.keystore");
    my($kssp) = gopt($mod, "keystore.storepass");
    my($kskp) = gopt($mod, "keystore.keypass", $kssp);
    my($alias) = gopt($mod, "keystore.alias", "privileged");
    if ($ks && $kssp && $kskp && $alias) {
      # use system so that we don't publish the passwords in the logs
      print STDERR "Signing $jar ($mod)\n" if ($verbose);
      system("$jarsigner_command $jarsigner_arguments -keystore $ks -storepass $kssp -keypass $kskp $jar $alias");
      push @signed_jars, $jar;
    } else {
      #print STDERR "Warning: Not enough information to sign $jar of $mod\n";
    }
  }
}

#
# here be utilities
#

sub mysystem {
  local($command)= @_;

  print STDERR "$command\n" if ($verbose>1);
  if ($pretend) {
    return 0;
  }

  if ($pid = fork ) {
    # parent
    waitpid $pid, 0;
    local($rc)= $?;
    # signal decoding from Perl5 manual
    $rc &= 0xffff;
    if ($rc != 0) {
      $sawerror++;
      if ($rc == 0xff00) {
	print STDERR "Command failed: $!\n";
      } elsif ($rc > 0x80) {
	$rc >>= 8;
	print STDERR "Completed with exit status of $rc\n";
      } else {
	print STDERR "Ran with ";
	if ($rc &  0x80) {
	  $rc &= 0x80;
	  print STDERR "coredump from ";
	}
	print STDERR "signal $rc\n";
      }
    }
  } elsif (defined $pid) {
    # child
    exec $command;
    print STDERR "$command: $!\n";
    exit(-1);
  } else {
    die "Couldn't run @_\n";
  }
}


sub sub_for_findbypattern {
   if (/^CVS$/) {
      $File::Find::prune = 1;
      return;
   }
   (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_));
   if (-d $_) {
      #      if (skipP($_)) {
      #       $File::Find::prune = 1;
      #       return;
      #      }
      ;
      } else {
         if (-f $_ && /$pat/) {
            push @stuff, $File::Find::name;
         }
      }
}

sub findbypattern {
  local($dir, $pat) = @_;
  local(@stuff);
  @stuff = ();
  # on win machines this directory sometimes has a newline...
  $dir = trimNewLine($dir);
  return @stuff if (! -e $dir);
#   local($code)= sub { 
#     if (/^CVS$/) {
#       $File::Find::prune = 1;
#       return;
#     }
#     (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_));
#     if (-d $_) {
# #      if (skipP($_)) {
# #	$File::Find::prune = 1;
# #	return;
# #      }
# ;
#     } else {
#       if (-f $_ && /$pat/) {
# 	push @stuff, $File::Find::name;
#       }
#     }
#   };
#   local(%ref);
#   $ref{"wanted"}=$code;
#   #&find(\%ref, $dir);
  find(\&sub_for_findbypattern, $dir);
  return @stuff;
}


sub sub_for_finddirs {
   if (/^CVS$/) {
      $File::Find::prune = 1;
   } else {
      if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -d $_ ) {
         push @stuff, $File::Find::name  if (!&skipP($File::Find::name));
      } 
   }
} 

sub finddirs {
  local($dir) = @_;
  local(@stuff);
  @stuff = ();
#   local($code)= sub { 
#     if (/^CVS$/) {
#       $File::Find::prune = 1;
#     } else {
#       if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -d $_ ) {
# 	push @stuff, $File::Find::name 	if (!&skipP($File::Find::name));
#       }
#     }
#   };
#   local(%ref);
#   $ref{"wanted"}=$code;
#   #&find(\%ref, $dir);
  find(\&sub_for_finddirs, $dir);
  @stuff;
}

#parse the input file
sub parse_config {
  my ($file) = @_;
  print "Parsing build parameter file \"$file\"\n" if ($verbose);

  open(STUFF,"<$file") || die("Could not open build script file '$file' for reading!\n");
  my $count = 0;
  my $leftover = "";
  while(<STUFF>) {
    chomp;
    $count++;

    s/\s*\#.*//; # drop comments immediately with leading whitespace
    s/[\n\r]//g; # drop extra newline / returns

    # incorporate previous wrapped line text
    if (! ($leftover eq "")) {
      $_ = "$leftover$_";
      $leftover = "";
    }

    next if (/^\s*$/);		# empty line - handles empty comment line, too

    # detect line wrap directives
    if (/(.*)\\[\n\r]*$/) {
      $leftover = $1;
      next;
    }

    print STDERR "$file (line $count): unknown format\n" if (! parseopt($_));
  }
  close(STUFF);

  foreach $_ (@opt_overrides) {
    print STDERR "Could not parse argument '-D$_'" if (! parseopt($_));
  }

  @modules = opt("modules");
}

sub parseopt {
  local ($_) = @_;
  if (/\s*(\S+)\s*=\s*(.+)\s*$/) {
    my $key = $1;
    my $val = $2;
    if ( exists $opts{$key} ) {
       print "build::parseopt() warning: Overwriting existing Key:Value pair: $key:$opts{$key} with $key:$val\n" if ($verbose>1);
    }
    $opts{$key}=$val;
    return 1;
  } else {
    return 0;
  }
}

sub listify {
  my ($s) = @_;
  return split(/\s*,\s*/, $s);
}

sub opt {
  my ($key, $default) = @_;
  my ($value) = $opts{$key};
  if ($value eq "") {
    $value = $default;
  }
  if (wantarray) {
    return listify($value);
  } else {
#      print STDERR "about to return val for $key: $value\n" if $verbose;
    return trimNewLine($value);
  }
}

# gopt first checks "$mod.$key" then "default.$key" for values
sub gopt {
  my ($mod, $key, $default) = @_;
  my ($value) = $opts{"$mod.$key"};
  if ($value eq "") {
    $value = opt("default.$key", $default);
  }
  if (wantarray) {
    return listify($value);
  } else {
    return $value;
  }
}

sub member {
  my ($key, @list) = @_;
  my $r = grep /^$key$/, @list;
  return $r;
}

sub isPublic {
  my ($mod) = @_;
  # backward compatability
  return 0 if (opt("$mod.internal")); # it is non-public if defined as internal.

  return 1 if (opt("$mod.public"));
  return 0 if (opt("$mod.private"));
  return 1 if (member($mod,opt("modules.public")));
  return 0 if (member($mod,opt("modules.private")));
  # default value
  return opt("default.public","1");
}

sub isUnified {
  my ($mod) = @_;
  # backward compatability
  return 1 if (opt("$mod.unified"));

  return member($mod,opt("modules.unified"));
}

sub sysPipe {
  my ($command) = @_;
  open(P, "$command|");
  my (@lines) = <P>;
  close(P);
  return @lines;
}

sub find_errors {
  print "\nSearching for errors\n" if ($verbose);

  open(LOG, "<$errout");
  open(ERR, ">$distdir/errors.out");
  my ($report)=sprintf "%15s %7s %7s\n", "module", "errors", "warnings";
  my ($te)=0;			# total errors
  my ($tw)=0;			# total warnings
  my ($mn);			# which module are we parsing?
  my ($ec) = 0;			# current module errors detected
  my ($wc) = 0;			# current module warnings detected
  my ($l) = 0;			# which line are we on?
  my ($cl) = -1;		# up to which line should we report on?
  while (<LOG>) {
    chomp;
    if (/Building module (\w*)/) {
      $mn = $1;
      $ec = 0; $wc = 0;
    }
    if (/Done building (\w+)/) {
      if ($mn eq $1) {
	$report .= sprintf "%15s %7d %7d\n", $mn, $ec, $wc ; # if ($ec || $wc);
	$te = $te+$ec;
	$tw = $tw+$wc;
	$mn = "";
      }
    }

    my $nl = 0;
    # search for jikes warnings
    if (/Issued (\d+) semantic warning/) {
      $wc += $1;		# incr warning count
      $nl = max($nl,(5 * $1));	# 5 lines per warning
    }
    # search for jikes errors
    if (/Found (\d+) semantic error/) {
      $ec += $1;		# incr warning count
      $nl = max($nl,(5 * $1));	# 5 lines per warning
    }
    if (/Found (\d+) syntax error/) {
      $ec += $1;		# incr warning count
      $nl = max($nl,(8 * $1));	# 8 lines per warning
    }

    # search for javac & javadoc (in 1.3/1.4) warnings/errors
    if (/\.java:(\d+):/) {
      if (/warning/) {
	$wc++;
      } else {
	$ec++;
      }
      $nl = max($nl,5);
    }
    if (/^Note: /) {		# dep warnings
      if (/Recompile with / ||
	  /Some input files/ ) {
	#ignore - not really specific enough to count
      } else {
	$wc++;
	$nl = max($nl,1);
      }
    }

    # catch junit errors
    if (/^There was (\d+) error/) {
      $ec++;
      $nl = max($nl,4);
    }

    # search for build errors/warnings
    if (/^Warning:/) {
      $wc++;
      $nl = max($nl,1);
    }

    # do we need to advance the context pointer?
    my($x) = $l+$nl;
    $cl = $x if ($cl<$x);

    # copy the line to err if needed
    print ERR "$_\n" if ($l<$cl);
    $l++;
  }
  close(LOG);

  $report .= sprintf "%15s %7d %7d\n", "total", $te, $tw;
  print ERR $report if ($te>0 || $tw>0);
  print STDERR $report;
  close(ERR);
}

sub max {
  my($x,$y) = @_;
  ($x>$y)?$x:$y;
}


sub getCVSROOT {
  my($mod) = @_;

  my $rept = opt("$mod.repository");
  if (!$rept) {
    $rept = opt("repository.default");
    $rept = "cougaar" if (!$rept);
  }

  if ($rept =~ /\//) {
    return $rept;
  } else {
    my $repb = opt("repository.base");
    # if repository.base isn't set, get it from CVSROOT which should be set to
    # something like "/cvs/alp/cougaar"
    if (! $repb) {
      $repb = $ENV{'CVSROOT'};
      if ($repb) {
	$repb =~ s/\/[^\/]+$/\//;
      } else {
	die("Couldn't figure out repository.base!\n");
      }
    }
    return "$repb$rept";
  }
}

sub tag {
  my($newtag) = @_;		# name to use for tagging

  my ($barg)="";
  $barg = "-b" if($branchP);

  my ($hairyP) = ($tag ne "HEAD") && ($rdate ne "");

  my (@mods);
  @mods = @modules;
  push @modules, "build" if (! member("build",@modules));

  {
    $syslib = opt("sys.lib");
    if ($syslib =~ /^module:(.+)/) {
      my($mod) = $1;
      push @mods, $mod;
    }
  }

  my $tmpdir = "$tmp/tagger.$$";
  mkd($tmpdir) if $hairyP;

  foreach $mod (@mods) {
    my $rep = getCVSROOT($mod);
    my $tag = opt("$mod.tag");
    $tag = $rtag if (!$tag);
    my $cvsmod = opt("$mod.module","$mod");

    my $arg = "";
    $arg = "-Q" if ($verbose<=1);
    my $rarg="";
    # special case for HEAD - bogon.
    $rarg = "-r $tag" if (! ($tag eq "HEAD"));
    my $Farg = $forceP?"-F":"";
    if ($hairyP) {
      # sigh.  Have to do a checkout and then local tag
      chdir("$tmpdir");
      mysystem("cvs $arg -d '$rep' co $rarg -D '$rdate' -d $mod $cvsmod");
      chdir("$tmpdir/$mod");
      mysystem("cvs $arg -d '$rep' tag $barg $Farg $newtag .");
      chdir("$tmpdir");
      mysystem("rm -rf $tmpdir/$mod");
    } else {
      mysystem ("cvs $arg -d '$rep' rtag $rarg -D '$rdate' $barg $Farg $newtag $cvsmod");
    }
  }
  if ($hairyP) {
    chdir("/");
    mysystem("rm -rf $tmpdir");
  }
}

sub junit {
  my ($mod, $classdir, $extrajars) = @_;
  my $cp = get_classpath($mod,1); # get runtime jars, too
  if ($extrajars) {
    $cp = "$extrajars$cpsep$cp";
  }
  my $syslib = $syslib;
  if (-e "$syslib/junit.jar") {
    $cp = "$cp$cpsep$syslib/junit.jar";
  } else {
    print "Error: cannot find junit.jar in sys.lib: regress($mod) will probably fail.\n";
  }

  if (-e "$classdir/Regress.class") {
    java("$classdir$cpsep$cp","junit.textui.TestRunner Regress");
  } else {
    print "Error: Module $mod has a regress directory, but no compilable Regress.class\n";
  }
}

sub compile_dir {
  my ($mod, $from, $to, $extrajars) = @_;
  my $cp = get_classpath($mod);
  if ($extrajars) {
    $cp = "$extrajars$cpsep$cp";
  }

  if (-d $from) {		# src exists
    print "Compiling $from\n" if $verbose;

    my $cp = get_classpath($mod);
    if ($extrajars) {
      $cp = "$extrajars$cpsep$cp";
    }

    # run code generators
    generate_code($from, $cp);
    # compile sources
    chdir $from;
    my $tmpfile = "$tmp/build.$$";
    mysystem("find . -name '*.java' -print>$tmpfile");
    if (-s $tmpfile) {
      javac($mod, $cp, "-d $to \@$tmpfile");
    } else {
      print "Error: Module $mod $from does not seem to actually have any sources to compile\n";
    }
    unlink($tmpfile);

    # search for files/classes to rmic
    my(@rmicfiles)=sysPipe("find . -name '*Impl.java' -exec grep -l 'UnicastRemoteObject' {} \\;");
    if ($#rmicfiles>=0) {
      foreach $rf (@rmicfiles) {
	chomp $rf;
	$rf =~ /\.\/(.*)\.java/;
	$rf=$1;
	$rf =~ s/\//\./g;
	rmic($mod, "$to$cpsep$cp", "-d $to $rf");
      }
    }

    # copy non-java "sources" to tmplib
    add_module_files($from, $to);
    return 1;
  } else {
    return 0;
  }
}

sub javac {
  my ($mod, $cp, $args) = @_;
  my ($time0) = time;
  my $jc = compiler_command($mod);
  $cp = &cpWrap($cp);
  $ENV{CLASSPATH}="$cp";
  $ENV{JIKESPATH}="$cp";
  print STDERR "CLASSPATH = $cp\n" if ($verbose>1);
  mysystem("$jc $args");
  undef $ENV{CLASSPATH};
  undef $ENV{JIKESPATH};
  my ($time1) = time;
  addtime("compile",$time1-$time0);
}
sub java {
  my ($cp, $args) = @_;
  my ($time0) = time;
  $cp = &cpWrap($cp);
  my ($j) = jdkCommand($java_command);
  $ENV{CLASSPATH}="$cp";
  print STDERR "CLASSPATH = $cp\n" if ($verbose>1);
  mysystem("$j $args");
  undef $ENV{CLASSPATH};
  my ($time1) = time;
  addtime("codegen",$time1-$time0);
}

sub rmic {
  my ($mod, $cp, $args) = @_;
  my ($time0) = time;
  $cp = &cpWrap($cp);
  $ENV{CLASSPATH}="$cp";
  print STDERR "CLASSPATH = $cp\n" if ($verbose>1);
  mysystem("$rmic_command $rmi_arguments $args");
  undef $ENV{CLASSPATH};
  my ($time1) = time;
  addtime("rmic",$time1-$time0);
}


sub compiler_command {
  my ($mod) = @_;
  my $jco = opt("$mod.compiler", "$compiler_touse");
  my $jc = opt("$jco.command");

  my $pedantic = opt("$mod.compiler.pedantic") || opt("compiler.pedantic");
  my $debug = opt("$mod.compiler.debug") || opt("compiler.debug");
  my $deprecation = opt("$mod.compiler.deprecation") || opt("compiler.deprecation");
  my $optimize = opt("$mod.compiler.optimize") || opt("compiler.optimize");
  my $args = opt("$mod.$jco.arguments") || opt("$jco.arguments");

  my $command = jdkCommand($jc);
  # pedantic only works for jikes
  $command .= " +P" if ($pedantic && $jco eq "jikes");
  $command .= " -g" if ($debug);
  $command .= " -deprecation" if ($deprecation);
  $command .= " -O" if ($optimize);
  $command .= " $args" if ($args ne "");

  return $command;
}


# Win machines sometimes add newline/returns
sub trimNewLine {
    my ($str) = @_;
    $str =~ s/[\n\r]*//g;
    return $str;
}

# Quote classpath on win platforms
sub cpWrap {
    my ($cp) = @_;
    if ($cpsep eq ";") {
	$cp = "\"$cp\"";
    }
    return $cp;
}

sub jdkCommand {
  my ($cmd) = @_;

  return $cmd if (absPath($cmd));

  # try javahome/bin
  my ($c) = "$java_home/bin/$cmd";
  return $c if (-x $c);
  return $cmd;			# hope for the best
}

sub absPath {
  my ($arg) = @_;
  return ($arg =~ /^\//);
}
sub cp {
  my($f, $t) = @_;
  return mysystem("cp $f $t");
}

sub warnonce {
  my($k, $w) = @_;
  if (! $once{$k}) {
    $once{$k}=1;
    print STDERR "Warning: $w\n";
  }
}

sub addtime {
  my ($k, $sec) = @_;
  $timers{$k} += $sec;
}

sub gettime {
  my ($k) = @_;
  $timers{$k};
}

sub reporttimes {
  print "Aggregate pass times (in seconds):\n";
  foreach $key (sort keys %timers) {
    print "\t$key\t$timers{$key}\n";
  }
}
