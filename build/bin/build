#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#  Copyright 2001 BBNT Solutions, LLC
#  under sponsorship of the Defense Advanced Research Projects Agency (DARPA).
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Cougaar Open Source License as published by
#  DARPA on the Cougaar Open Source Website (www.cougaar.org).
# 
#  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS
#  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR
#  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT
#  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT
#  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL
#  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS,
#  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
#  PERFORMANCE OF THE COUGAAR SOFTWARE.
# </copyright>

# run a full release build

use Cwd;
use File::Copy;
use File::Path;
use File::Find;

$opt_file = "default.build";
@opt_overrides;

$verbose = 1;

sub parse_args {
  while ($#ARGV>=0) {
    $_ = shift @ARGV;
    if ( /^-o(.+)/) {
      push @opt_overrides, $1;
    } elsif (/^-r/) {
      $opt_r = shift @ARGV;
    } elsif (/^-D/) {
      $opt_D = shift @ARGV;
    } elsif (/^-t/) {
      $tag = shift @ARGV;
    } elsif (/^-m/) {
      $opt_m = shift @ARGV;
    } elsif ( /^-(.+)/) {
      foreach $c (split //, $1) {
	if ($c eq "h") {
	  usage();
	} elsif ($c eq "v") {
	  $verbose++;
	} elsif ($c eq "q") {
	  $verbose--;
	} elsif ($c eq "n") {
	  $pretend = 1;
	  $verbose++;
	} elsif ($c eq "Q") {
	  $nodoc = 1;
	} elsif ($c eq "S") {
	  $skip = 1;
	} elsif ($c eq "c") {
	  $checkoutP = 1;
	} elsif ($c eq "b") {
	  $branchP = 1;
	} elsif ($c eq "F") {
	  $forceP = 1;
	} else {
	  usage();
	}
      }
    } else {
      $opt_file = $_;
      usage() if ($#ARGV!=-1);
    }
  }
}


sub usage {
  print STDERR <<EOF;
Usage: build [options] [ReleaseDescriptionFile]
	-S	Skip checkout, rebuild from last try
	-Q	Quick build (no documentation)
	-v	be verbose
	-q	be quiet
	-n	show what would be done, but dont do it.  Implies -v.
	-c	checkout cvs sources from head of tag rather than export from timestamp point
	-okey=value	set parameters on the command line
	-D date	Specify a repository date to build/tag relative to
	-r tag	Specify a repository tag to build/tag relative to
	-t name	Tag (with name) instead of building (also uses -r and -D)
	-b	When tagging, branch instead of simple tag
	-F	When tagging, Force the tag (move the tag if it previously existed)
	-m mod[,...]	Specify a module or modules to build instead of all.

The default ReleaseDescriptionFile is "default.build".  If the file is not
found as specified, it will try to check from cvs using the current CVSROOT from
build/data/<ReleaseDescriptionFile> and use that.

Examples:
Standard verbose build of the HEAD:
	build -v default.build
Retroactively point-tag the repositories at a specific date:
	build  -D '7/31/2001 10:00:11' -t V8_3_0 default.build
Build blackjack (and all required parts):
	build -m blackjack default.build
EOF

  exit(1);
}

@modules;			# list of modules to build.
%moduleDone;			# has a given module been built?
@depstack;			# stack of module dependencies being considered.

%opts;
parse_args();
if (-e $opt_file) {
  print "parsing $opt_file\n";
  parse_config($opt_file);
} else {
  my($of)="/tmp/$$.build";
  mysystem("cvs -Q co -p build/data/$opt_file>$of");
  parse_config($of);
  unlink($of);
}

if ( -e "$ENV{HOME}/.cougaar-build-system-specific" )  {
  print "parsing $ENV{HOME}/.cougaar-build-system-specific\n";
  parse_config("$ENV{HOME}/.cougaar-build-system-specific");
}

#$compiler_command = "jikes";
$compiler_command = "javac";
addopt("javac.command", "javac");
addopt("jikes.command", "jikes");
addopt("javac.arguments", "-J-Xmx128m -J-Xms128m");

sub addopt {
  my ($key, $val) = @_;
  $opts{$key} = $val if (! exists $opts{$key});
}

$rmic_command = "rmic -g -v1.2";

$java_command = "java";
$compiler_command = opt("compiler",$compiler_command);
$java_command = opt("java", $java_command);
$javadoc_command = opt("javadoc", $javadoc_command);

if ($opt_m) {
  @modules = compute_modules($opt_m);
  push @modules, "build" if (! member("build",@modules));
  my $foo = join(", ", @modules);
  print "Computed modules from $opt_m = \n\t$foo\n";
}

sub compute_modules {
  my ($modspec) = @_;
  local(%done);
  local(@acc);
  local(@stack);
  foreach $mod (split /\s*,\s*/, $modspec) {
    compute_modules1($mod) if (! $done{$mod});
  }
  return @acc;
}

sub compute_modules1 {
  my ($mod) = @_;
  return if ($done{$mod});
  if (member($mod,@stack)) {
    die "Fatal error: dependency loop: $mod in @acc\n";
  }
  push @stack, $mod;
  my ($foo) = opt("$mod.deps");
  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    if (! $done{$dep}) {
      compute_modules1($dep);
    }
  }
  pop @stack;
  $done{$mod}=1;
  push @acc, $mod;
}

{
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  $rdate="$mon/$mday/$yr $hour:$min:$sec";
  # build time for build directory name
  $mon="0$mon" if ($mon<10);
  $mday="0$mday" if ($mday<10);
  $hour="0$hour" if($hour<10);
  $yr=$yr-2000;
  $yr="0$yr" if ($yr<10);
  $bdate="$yr$mon$mday$hour$min$sec";
}


# repository tag for build
if ($opt_r) {
  $rtag = $opt_r;
} else {
  $rtag = opt("tag.default");
  if (! $rtag) {
    $rtag = "HEAD";
  }
}

# build time
$rdate = $opt_D if ($opt_D);

# root of the build directory tree
$build_root = opt("build.root");
if (! $build_root) {
  my $foo = opt("product.name");
  die("Could not figure out build.root!\n") if (!$foo);
  $build_root = "/tmp/$foo";
}

if ($skip) {
  opendir D, $build_root;
  @alldirs = grep !/^\./, readdir D;
  closedir D;
  @alldirs = grep /[0-9]+/, @alldirs;
  @alldirs = sort @alldirs;
  @alldirs = reverse @alldirs;

  $bdate = $alldirs[0];
  print STDERR "Latest = $bdate\n";
}

# absolute path of directory we are building into
$build_dir = "$build_root/$bdate";

# just a copy of the enviroment variable (or maybe a command line option)
$sysclasspath;
@sysjars;
# skip the classpath evar and use the sys.lib param
{
  @sysjars = findbypattern(opt("sys.lib"), "\.(jar|zip)\$");
  $sysclasspath = join(":", @sysjars);
}


# classpath, possibly with rt.jar added for use by jikes
$augmented_classpath = $sysclasspath;
@rtjars;
# hack for jikes until it is Java2 complient
if ( $compiler_command =~ /jikes/ ) {
  my $javahome;
  if ( $java_command =~ /^(.+)\/bin\/java$/ ) {
    $javahome = $1;
  } else {
    open(JAVA, "which java|");
    my $line = <JAVA>;
    close(JAVA);
    if ($line =~ /(.*)\/bin\/java/) {
      $javahome = $1;
    } else {
      die("Cannot find java");
    }
  }
  if ($javahome) {
    $rtjar = "$javahome/jre/lib/rt.jar";
    @rtjars = ($rtjar);
    $augmented_classpath = "$augmented_classpath:$rtjar";
  }
}

# record start time for later measurement
$start_time = time;


# subdir containing all the sources
$srcdir = "$build_dir/src";

$product = opt("product.name");

$latest_dir = "$build_root/latest";

if ($tag) {
  tag($tag);
  exit(0);
}

sub mkd {
  my($p) = @_;
  mkdir $p, 0777 if (!$pretend);
}

# create the build dirs
mkd "$build_root";
mkd $build_dir;
unlink "$latest_dir";
print "ln -s $build_dir $latest_dir\n" if $verbose;
symlink "$build_dir", "$latest_dir";
mkd $srcdir;
# libdir is where we store built jars
$libdir = "$build_dir/lib";
mkd $libdir;
# distdir is where we put end products
$distdir = "$build_dir/dist";
mkd $distdir;

chdir($distdir) || die("Couldn't chdir to $distdir");

# redirect streams to file
$errout = "$distdir/build.out";
open(SAVEOUT, ">&STDOUT");
open(SAVEERR, ">&STDERR");
#open(STDOUT, ">$errout");  # direct to file
open(STDOUT, "|tee $errout");  # tee to file
open(STDERR, ">&STDOUT");
select STDERR; $| = 1;		# unbuffered
select STDOUT; $| = 1;

print "Building $rtag at $rdate into $build_dir\n"  if $verbose;
print "Output is in $errout\n" if $verbose;

# Check out everything from CVS
&checkout if (!$skip);

# build the modules
&build;

# build unified source tree
&unify;

# build product.zip
&build_runtime;

# build product-support.zip
&build_3rdparty;

# build unified javadoc
&build_javadoc("unified", "$product-api") if (!$nodoc);

# add any dist extras
&add_dist;

# find and report on errors/warnings
&find_errors();

add_md5("$build_dir/dist");

# get end time and report on elapsed time
{
  $end_time = time;
  $delta = $end_time - $start_time;
  $min = int ($delta/60);
  $sec = $delta%60;
  print "Elapsed time = $min minutes $sec seconds\n" if $verbose;
}

exit(0);

#
# the pass routines
#

# moby checkout
sub checkout {
  print "\nStarting checkout\n" if $verbose;
  mkd $srcdir;
  chdir ($srcdir) || die ("Couldn't chdir to $build_dir");

  foreach $mod (@modules) {
    my $rep = getCVSROOT($mod);

    my $tag = opt("$mod.tag");
    $tag = $rtag if (!$tag);

    my $arg = "";
    $arg = "-Q";# if ($verbose<=1);
    my $rarg="";
    # special case for HEAD - bogon.
    $rarg = "-r $tag" if (! ($tag eq "HEAD"));
    if ($checkoutP) {
      # hack to allow us to checkout a branch at a specific time
      $rarg .= " -D '$opt_D'" if ($opt_D);
      # leave it in development mode
      mysystem ("cvs $arg -d '$rep' checkout $rarg -d $mod $mod");
    } else {
      mysystem ("cvs $arg -d '$rep' export $rarg -D '$rdate' -d $mod $mod");
    }
  }

  print "Checkout complete\n" if $verbose;
}

#
# moby build of modules
#

sub build {
  print "\nStarting building modules\n" if $verbose;

  build_module("build") || die("Compile of build module failed");

  foreach $mod (@modules) {
    build_module($mod) if (! ($mod eq "build"));
  }
  print "Finished building modules\n" if $verbose;
}

sub checkDeps {
  my ($mod) = @_;
  return if ($moduleDone{$mod}); # don't bother to check
  # check for loops
  if (member($mod, @depstack)) {
    die "Fatal Error: detected dependency loop: $mod @depstack\n";
  }
  push @depstack, $mod;		# add the current mod to the stack
  # build the submodules
  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    if (! $moduleDone{$dep}) {
      build_module($dep);
    }
  }
  pop @depstack;		# pop the current mod from the stack
}

sub build_module {
  my ($mod) = @_;
  return if ($moduleDone{$mod});

  checkDeps($mod);

  my $mymod = "$srcdir/$mod";
  print "\nBuilding module $mod\n" if $verbose;

  my $mysrc = "$mymod/src";
  my $tmplib = "/tmp/build-lib$$";

  if (-d $mysrc) {
    print "Compiling $mod src:\n" if $verbose;
    mysystem("rm -rf $tmplib");
    mkd $tmplib;

    if (compile_dir($mod, $mysrc, $tmplib)) {
      print "Preparing jar for $mod\n" if $verbose;
      # create jar
      chdir ($tmplib);
      jar("$product/$mod runtime", $tmplib, "$libdir/$mod.jar", "$mysrc/manifest.mf");
    }
    # clean up
    chdir ($mysrc);
    mysystem("rm -rf $tmplib");
  }

  my $myex = "$mymod/examples";
  if ( -d $myex) {
    print "Compiling $mod examples:\n" if $verbose;
    mysystem("rm -rf $tmplib");
    mkd $tmplib;

    # compile examples, but don't jar the results up
    compile_dir($mod, $myex, $tmplib, "$libdir/$mod.jar");

    # clean up
    chdir ($mysrc);
    mysystem("rm -rf $tmplib");
  }

  my $myreg = "$mymod/regress";
  if (-d $myreg) {
    print "Compiling $mod regression tests:\n" if $verbose;
    mysystem("rm -rf $tmplib");
    mkd $tmplib;
    my $extrajars = "$libdir/$mod.jar";
    my $syslib = opt("sys.lib");
    if (-e "$syslib/junit.jar") {
      $extrajars = "$extrajars:$syslib/junit.jar";
    } else {
      print "Warning: could not find $syslib/junit.jar -- regression tests will probably fail.";
    }
    # compile regress tests, but don't jar the results up
    compile_dir($mod, $myreg, $tmplib, $extrajars);

    print "Running $mod regression tests:\n" if $verbose;
    junit($mod, $tmplib, "$libdir/$mod.jar");

    # clean up
    chdir ($mysrc);
    mysystem("rm -rf $tmplib");

  }

  # now create the product-module.zip file
  if (isPublic($mod)) {
    my $tmpdir = "/tmp/build-$mod.$$";
    mkd $tmpdir;
    my $tmpdist = "$tmpdir/$mod";
    mkd "$tmpdist";

    chdir "$srcdir/$mod";
    # bin,data,configs are now shipped as runtime parts.
    my @shipped_subdirs = ( "src", "examples", "regress" );
    my @subdirs = ();
    foreach $sub (@shipped_subdirs) {
      if (-d "$srcdir/$mod/$sub") {
	push @subdirs, $sub ;
      }
    }

    my $subdirs = join(" ", @subdirs);
    if ($subdirs) {
      mysystem("tar cf - $subdirs | (cd $tmpdist; tar xf -)");

      # only do javadoc if it is not part of the unified build
      if (! isUnified($mod)) {
	mkd "$tmpdist/api";
	javadoc($mod, $mysrc, "$tmpdist/api") if (!$nodoc);
      }

      zip("$product $module", $tmpdir, "$distdir/$mod-dev.zip");
    }

    chdir($mysrc);
    mysystem("rm -rf $tmpdir");
  }

  print "Done building $mod\n" if $verbose;
  $moduleDone{$mod}=1;
  return 1;
}

# try to find exactly the set of jars needed based on dependencies, etc
#
sub get_classpath {
  local($mod) = @_;

  if ($mod eq "unified") {
    return get_unified_classpath();
  }
  # previously built jars
  my @buildjars = findbypattern($libdir, "\.jar\$");

  # current module's lib jars
  my @libjars = findbypattern("$srcdir/$mod/lib", "\.(jar|zip)\$");

  #put them together - module jars never take precedence
  my @alljars = (@buildjars, @sysjars, @libjars);

  # check the libjars carefully just in case someone is doing something stupid.
  {
    my @goodjars = (@buildjars, @sysjars);
    foreach $loclib (@libjars) {
      if ( ($loclib =~ /([^\/]+)\.(zip|jar)/) ) {
	my $match = $1;
	my @goods = grep /$1\.(zip|jar)$/, @goodjars;
	if ($#goods>=0) {
	  my $rc = mysystem("cmp $loclib $goods[0]");
	  print STDERR "Warning: Module $mod specifies $match as:\n\t$loclib\nwhich is also in:\n\t@goods\n\tmodule-local version will be ignored!\n";
	  if ($rc) {
	    print STDERR "Warning: $loclib and $goods[0] actually differ!\n";
	  } else {
	    print STDERR "The good news is that the $loclib and $goods[0] are the same.\n" if $verbose;
	  }
	}
      }
    }
  }

  # fill this up with required jars
  my @cp;

  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    my $jar = findjar($dep, @alljars);
    if ($jar eq "") {
      print "Warning: could not find $dep module for $mod\n";
    } else {
      push @cp, $jar;
    }
  }
  foreach $dep (split /\s*,\s*/, opt("$mod.jars")) {
    my $jar = findjar($dep, @alljars);
    if ($jar eq "") {
      print "Warning: could not find $dep jar for $mod\n";
    } else {
      push @cp, $jar;
    }
  }

  my @libs = (@cp, @rtjars);
  my $cp = join(":",@libs);
  return ".:$cp";
}

sub get_unified_classpath {
  my %member;
  my @cp;
  foreach $m (@modules) {
    if (isUnified($m)) {
      foreach $c (split(/:/,get_classpath($m))) {
	if (! ($member{$c})) {
	  $member{$c} = 1;
	  push @cp, $c;
	}
      }
    }
  }
  return join(":", @cp);
}

sub findjar {
  local($name, @jars) = @_;
  my $pat = "\/$name\.(jar|zip)\$";
  foreach $_ (@jars) {
    return $_ if (/$pat/);
  }
  "";
}

sub add_module_files {
  local ($mysrc, $tmplib) = @_;
  chdir $mysrc;
  my $files = join(" ", findbypattern(".", "\.(def|gif|jpg|png|html|htm)\$"));
  if (! $files eq "") {
    mysystem("tar cf - $files | (cd $tmplib ; tar xf -)");
  }
}


# find all .def files and run the code generators on them
sub generate_code {
  my ($src, $cp) = @_;
  my @defs = findbypattern($src, "\.def\$");
  my $n = $#defs+1;
  for (@defs) {
    rundef($_, $cp);
  }
}

# code generate a single .def file
sub rundef {
  my ($path, $cp)=@_;
  open(DEF, "<$path");
  local($line);
  $line = <DEF>;
  local($rc)= -1;
  # if the first line is ";!generate: ..." then we'll use
  # it to build the def.
  if ( ($line =~ /\!generate:\s*(.*)$/) ) {
    $command = $1;	 
    # first word is the generator class
    @words = split /\s/, $command;

    # dirpath is the directory where the def file is
    @dirpath = split /\//, $path;
    pop @dirpath;
    $dirpath = join "/",@dirpath;

    # figure out the package name
    $class = $words[0];
    @pkgp = split /\./, $class;
    $pkgp = join "/",@pkgp;

    #print "Running $class\n" if $verbose;
    $args = join " ", @words[1..$#words];
    chdir($dirpath);
    my ($dargs) = "-Drepository.tag='$rtag' -Drepository.time='$rdate'";
    if ($skip || $checkoutP) {
      $dargs .= " -Drepository.modified=true";
    }
    $rc = java("$libdir/build.jar:$cp", "$dargs $class $args $path");
  }
  close(DEF);
  return $rc;
}


#
# build the unified tree
#
sub unify {
  my $mod = "unified";
  my $mysrc = "$srcdir/$mod/src";

  print "\nBuilding unified sources\n" if $verbose;
  mkd "$srcdir/$mod";
  mkd "$mysrc";

  foreach $m (@modules) {
    print "Adding module $m sources\n" if $verbose;
    if (isUnified($m)) {
      my $nbase = "$srcdir/$m";
      my $nsrc = "$nbase/src";
      chdir $nsrc;
      mysystem("tar cf - . | (cd $mysrc ; tar xf - )");
    }
  }
  print "Done building unified sources\n" if $verbose;
}

#
# build the runtime package
#
sub build_runtime {
  my $mod;
  my $tmpdir = "/tmp/runtime.$$";
  print "\nBuilding runtime dist\n" if $verbose;
  mkd $tmpdir;
  my $tl = "$tmpdir/lib";
  mkd $tl;
  foreach $mod (@modules) {
    print "Adding $mod runtime\n" if $verbose;
    if (-e "$build_dir/lib/$mod.jar") {
      mysystem("cp $build_dir/lib/$mod.jar $tl");
    }
    my $moddir = "$srcdir/$mod";
    chdir $moddir;

    my @extras = opt("$mod.runtime");
    foreach $extra (@extras) {
      mysystem("tar cf - $extra | (cd $tmpdir; tar xf -)");
    }

    my @runtime_subdirs = ("bin", "data", "configs", "doc");
    foreach $rs (@runtime_subdirs) {
      if (member($rs, @extras)) { # skip top-level bits
	print "Skipping duplicate install of $mod/$rs\n" if $verbose;
      } else {
	if (-e "$moddir/$rs") {
	  chdir "$moddir";
	  mkd "$tmpdir/$mod";
	  mkd "$tmpdir/$mod/$rs";
	  mysystem("tar cf - $rs | (cd $tmpdir/$mod ; tar xf -)");
	}
      }
    }
  }

  chdir $tmpdir;
  zip("$product runtime", $tmpdir, "$distdir/$product.zip");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building runtime dist\n" if $verbose;
}

# build the 3rdparty zip - mostly 3rd party jars.
sub build_3rdparty {
  my %member;
  my $mod;
  my $tmpdir = "/tmp/runtime.$$";
  print "\nBuilding 3rdparty dist\n" if $verbose;
  mkd $tmpdir;
  my $tl = "$tmpdir/sys";
  mkd $tl;

  # grab the modules (checked-in) jars
  foreach $mod (@modules) {
    my @libjars = findbypattern("$srcdir/$mod/lib", "\.(jar|zip)\$");
    my @alljars = (@sysjars, @libjars);	# prefer sysjars

    my @deps = ((split /\s*,\s*/, opt("$mod.jars")),
		(split /\s*,\s*/, opt("$mod.extras")));
    foreach $dep (@deps) {
      my $jar = findjar($dep, @alljars);
      if (!$jar) {
	my $foo = join(":",@alljars);
	print STDERR "Warning: could not find $dep in $foo\n";
      }
      if ($jar && ! ($member{$jar})) {
	  $member{$jar} = 1;
	  mysystem("cp $jar $tl");
	}
    }
  }

  chdir $tmpdir;
  zip("$product thirdparty jars", $tmpdir, "$distdir/$product-support.zip");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building 3rdparty dist\n" if $verbose;
}

sub build_javadoc {
  local($mod,$dest)=@_;

  $dest = "$mod-api" if ($dest eq "");

  print "\nBuilding javadoc of $mod\n" if $verbose;

  # generate javadoc from unified source
  my $tmpdir = "/tmp/javadoc.$$";
  mkd $tmpdir;
  mkd "$tmpdir/api";
  javadoc($mod, "$srcdir/$mod/src", "$tmpdir/api");

  chdir $tmpdir;
  zip("$product javadoc apis", $tmpdir, "$distdir/$dest.zip");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building javadoc for $mod\n" if $verbose;
}

sub add_dist {
  my $mod;
  print "\nCompleting dist package\n" if $verbose;
  foreach $mod (@modules) {
    my $dusts = opt("$mod.dist");
    if ($dusts) {
      my $moddir = "$srcdir/$mod";
      chdir $moddir;
      my @dust = split(/\s*,\s*/, $dusts);
      foreach $dust (@dust) {
	my $d = $moddir;
	my $f = $dust;
	if ($dust =~ /(.*)\/([^\/]*)/) {
	  $d = "$moddir/$1";
	  $f = $2;
	}
	mysystem("(cd $d; tar cf - $f) | (cd $distdir; tar xf -)");
      }
    }
  }
  print "Done adding to dist package\n" if $verbose;
}


sub javadoc {
  local($mod, $src,$dst) = @_;
  my %pmap;
  chdir "$src";
  # find all the directories with packages and convert 
  open(LIST, "find . -name '*.java' -print|");
  while (<LIST>) {
    my $line = $_;
    my $p = rindex($line, '/') - 2;
    if ($p > 0) {
      $line = substr($line, 2, $p);
      $line =~ s/\//\./g;
      $pmap{$line}=1;
    }
  }
  close(LIST);
  my $pkgs = join(" ", keys %pmap);
  my $cp = get_classpath($mod);
  mysystem("$javadoc_command -classpath $cp -splitIndex -d $dst -sourcepath . $pkgs");
}

# zip up a directory, adding appropriate comments, sums, etc.
sub zip {
  local($comment, $dir, $dest) = @_;
  chdir $dir;
  add_info($comment, $dir);
  mysystem("zip -qr $dest *");
}

sub jar {
  local($comment, $dir, $dest, $mf) = @_;
  chdir $dir;
  add_info($comment, $dir);
  if (-r $mf) {
    mysystem("jar cmf $mf $dest *");
  } else {
    mysystem("jar cf $dest *");
  }
}

sub add_info {
  local($comment, $dir) = @_;
  open(OUT, ">$dir/version.txt");
  print OUT "COMMENT = $comment\n";
  print OUT "REPOSITORY_TAG = $rtag\n";
  print OUT "REPOSITORY_TIME = $rdate\n";
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  my $d ="$mon/$mday/$yr $hour:$min:$sec";
  print OUT "ARCHIVE_TIME = $d\n";
  close OUT;
}

sub add_md5 {
  local($dir) = @_;
  chdir($dir);
  my @archives = findbypattern(".", "\.(jar|zip|tar|tgz)\$");
  my @list;
  foreach $a (@archives) {
    $a =~ s/^\.\///;
    push @list, $a;
  }
  my $list = join(" ", @list);
  mysystem("md5sum $list > md5sums.txt");
}

#
# here be utilities
#

sub mysystem {
  local($command)= @_;

  print STDERR "$command\n" if ($verbose>1);
  if ($pretend) {
    return 0;
  }

  if ($pid = fork ) {
    # parent
    waitpid $pid, 0;
    local($rc)= $?;
    # signal decoding from Perl5 manual
    $rc &= 0xffff;
    if ($rc != 0) {
      $sawerror++;
      if ($rc == 0xff00) {
	print STDERR "Command failed: $!\n";
      } elsif ($rc > 0x80) {
	$rc >>= 8;
	print STDERR "Completed with exit status of $rc\n";
      } else {
	print STDERR "Ran with ";
	if ($rc &  0x80) {
	  $rc &= 0x80;
	  print STDERR "coredump from ";
	}
	print STDERR "signal $rc\n";
      }
    }
  } elsif (defined $pid) {
    # child
    exec $command;
    print STDERR "$command: $!\n";
    exit(-1);
  } else {
    die "Couldn't run @_\n";
  }
}


sub sub_for_findbypattern {
   if (/^CVS$/) {
      $File::Find::prune = 1;
      return;
   }
   (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_));
   if (-d $_) {
      #      if (skipP($_)) {
      #       $File::Find::prune = 1;
      #       return;
      #      }
      ;
      } else {
         if (-f $_ && /$pat/) {
            push @stuff, $File::Find::name;
         }
      }
} 

sub findbypattern {
  local($dir, $pat) = @_;
  local(@stuff);
  @stuff = ();
  return @stuff if (! -e $dir);
#   local($code)= sub { 
#     if (/^CVS$/) {
#       $File::Find::prune = 1;
#       return;
#     }
#     (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_));
#     if (-d $_) {
# #      if (skipP($_)) {
# #	$File::Find::prune = 1;
# #	return;
# #      }
# ;
#     } else {
#       if (-f $_ && /$pat/) {
# 	push @stuff, $File::Find::name;
#       }
#     }
#   };
#   local(%ref);
#   $ref{"wanted"}=$code;
#   #&find(\%ref, $dir);
  find(\&sub_for_findbypattern, $dir);
  return @stuff;
}


sub sub_for_finddirs {
   if (/^CVS$/) {
      $File::Find::prune = 1;
   } else {
      if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -d $_ ) {
         push @stuff, $File::Find::name  if (!&skipP($File::Find::name));
      } 
   }
} 

sub finddirs {
  local($dir) = @_;
  local(@stuff);
  @stuff = ();
#   local($code)= sub { 
#     if (/^CVS$/) {
#       $File::Find::prune = 1;
#     } else {
#       if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -d $_ ) {
# 	push @stuff, $File::Find::name 	if (!&skipP($File::Find::name));
#       }
#     }
#   };
#   local(%ref);
#   $ref{"wanted"}=$code;
#   #&find(\%ref, $dir);
  find(\&sub_for_finddirs, $dir);
  @stuff;
}

#parse the input file
sub parse_config {
  my ($file) = @_;

  open(STUFF,"<$file") || die("Could not open build script file '$file' for reading!\n");
  my $count = 0;
  my $leftover = "";
  while(<STUFF>) {
    chomp;
    $count++;

    s/\s*\#.*//; # drop comments immediately with leading whitespace

    # incorporate previous wrapped line text
    if (! ($leftover eq "")) {
      $_ = "$leftover$_";
      $leftover = "";
    }

    next if (/^\s*$/);		# empty line - handles empty comment line, too

    # detect line wrap directives
    if (/(.*)\\$/) {
      $leftover = $1;
      next;
    }

    print STDERR "$file (line $count): unknown format\n" if (! parseopt($_));
  }
  close(STUFF);

  foreach $_ (@opt_overrides) {
    print STDERR "Could not parse argument '-D$_'" if (! parseopt($_));
  }

  @modules = opt("modules");
}

sub parseopt {
  local ($_) = @_;
  if (/\s*(\S+)\s*=\s*(.+)\s*$/) {
    my $key = $1;
    my $val = $2;
    if ( exists $opts{$key} ) {
       print "build::parseopt() warning: Overwriting existing Key:Value pair: $key:$opts{$key} with $key:$val\n";
    }
    $opts{$key}=$val;
    return 1;
  } else {
    return 0;
  }
}

sub listify {
  my ($s) = @_;
  return split(/\s*,\s*/, $s);
}

sub opt {
  my ($key, $default) = @_;
  my ($value) = $opts{$key};
  if ($value eq "") {
    $value = $default;
  }
  if (wantarray) {
    return listify($value);
  } else {
    return $value;
  }
}

sub member {
  my ($key, @list) = @_;
  my $r = grep /^$key$/, @list;
  return $r;
}

sub isPublic {
  my ($mod) = @_;
  # backward compatability
  return 0 if (opt("$mod.internal")); # it is non-public if defined as internal.

  return member($mod,opt("modules.public"));
}

sub isUnified {
  my ($mod) = @_;
  # backward compatability
  return 1 if (opt("$mod.unified"));

  return member($mod,opt("modules.unified"));
}

sub sysPipe {
  my ($command) = @_;
  open(P, "$command|");
  my (@lines) = <P>;
  close(P);
  return @lines;
}

sub find_errors {
  print "\nSearching for errors\n" if ($verbose);

  open(LOG, "<$errout");
  open(ERR, ">$distdir/errors.out");
  my ($ec) = 0;			# errors detected
  my ($wc) = 0;			# warnings detected
  my ($l) = 0;			# which line are we on?
  my ($cl) = -1;		# up to which line should we report on?
  while (<LOG>) {
    chomp;
    $nl = 0;
    # search for jikes warnings
    if (/Issued (\d+) semantic warning/) {
      $wc += $1;		# incr warning count
      $nl = max($nl,(5 * $1));	# 5 lines per warning
    }
    # search for jikes errors
    if (/Found (\d+) semantic error/) {
      $ec += $1;		# incr warning count
      $nl = max($nl,(5 * $1));	# 5 lines per warning
    }

    # search for javac (in 1.3) warnings/errors
    if (/\.java:(\d+):/) {
      if (/warning:/) {
	$wc++;
      } else {
	$ec++;
      }
      $nl = max($nl,5);
    }
    if (/^Note: /) {		# dep warnings
      $wc++;
      $nl = max($nl,1);
    }

    # search for build errors/warnings
    if (/^Warning:/) {
      $wc++;
      $nl = max($nl,1);
    }

    # do we need to advance the context pointer?
    my($x) = $l+$nl;
    $cl = $x if ($cl<$x);

    # copy the line to err if needed
    print ERR "$_\n" if ($l<$cl);
    $l++;
  }
  close(LOG);

  print ERR "\nTotal $ec errors and $wc warnings\n" if ($ec>0 || $wc>0);
  close(ERR);

  print STDERR "\nTotal $ec errors and $wc warnings\n" if ($ec>0 || $wc>0);
}

sub max {
  my($x,$y) = @_;
  ($x>$y)?$x:$y;
}


sub getCVSROOT {
  my($mod) = @_;

  my $rept = opt("$mod.repository");
  if (!$rept) {
    $rept = opt("repository.default");
    $rept = "cougaar" if (!$rept);
  }

  if ($rept =~ /\//) {
    return $rept;
  } else {
    my $repb = opt("repository.base");
    # if repository.base isn't set, get it from CVSROOT which should be set to
    # something like "/cvs/alp/cougaar"
    if (! $repb) {
      $repb = $ENV{'CVSROOT'};
      if ($repb) {
	$repb =~ s/\/cougaar$/\//;
      } else {
	die("Couldn't figure out repository.base!\n");
      }
    }
    return "$repb$rept";
  }
}

sub tag {
  my($newtag) = @_;		# name to use for tagging
  my ($barg)="";
  $barg = "-b" if($branchP);

  foreach $mod (@modules) {
    my $rep = getCVSROOT($mod);

    my $tag = opt("$mod.tag");
    $tag = $rtag if (!$tag);

    my $arg = "";
    $arg = "-Q" if ($verbose<=1);
    my $rarg="";
    # special case for HEAD - bogon.
    $rarg = "-r $tag" if (! ($tag eq "HEAD"));
    my $Farg = $forceP?"-F":"";
    mysystem ("cvs $arg -d '$rep' rtag $rarg -D '$rdate' -F $barg $Farg $newtag $mod");
  }
}

sub junit {
  my ($mod, $classdir, $extrajars) = @_;
  my $cp = get_classpath($mod);
  if ($extrajars) {
    $cp = "$extrajars:$cp";
  }
  my $syslib = opt("sys.lib");
  if (-e "$syslib/junit.jar") {
    $cp = "$cp:$syslib/junit.jar";
  } else {
    print "Error: cannot find junit.jar in sys.lib: regress($mod) will probably fail.\n";
  }

  if (-e "$classdir/Regress.class") {
    java("$classdir:$cp","junit.textui.TestRunner Regress");
  } else {
    print "Error: Module $mod has a regress directory, but no compilable Regress.class\n";
  }
}

sub compile_dir {
  my ($mod, $from, $to, $extrajars) = @_;
  my $cp = get_classpath($mod);
  if ($extrajars) {
    $cp = "$extrajars:$cp";
  }

  if (-d $from) {		# src exists
    print "Compiling $from\n" if $verbose;

    my $cp = get_classpath($mod);
    if ($extrajars) {
      $cp = "$extrajars:$cp";
    }

    # run code generators
    generate_code($from, $cp);
    # compile sources
    chdir $from;
    my $tmpfile = "/tmp/build.$$";
    mysystem("find . -name '*.java' -print>$tmpfile");
    my $jc = compiler_command($mod);
    if (-s $tmpfile) {
      mysystem("$jc -d $to -classpath $cp \@$tmpfile");
    } else {
      print "Error: Module $mod $from does not seem to actually have any sources to compile\n";
    }
    unlink($tmpfile);

    # search for files/classes to rmic
    my(@rmicfiles)=sysPipe("find . -name '*Impl.java' -exec grep -l 'UnicastRemoteObject' {} \\;");
    if ($#rmicfiles>=0) {
      foreach $rf (@rmicfiles) {
	chomp $rf;
	$rf =~ /\.\/(.*)\.java/;
	$rf=$1;
	$rf =~ s/\//\./g;
	mysystem("$rmic_command -d $to -classpath $to:$cp $rf");
      }
    }

    # copy non-java "sources" to tmplib
    add_module_files($from, $to);
    return 1;
  } else {
    return 0;
  }
}

sub java {
  my ($cp, $args) = @_;
  mysystem("$java_command -classpath $cp $args");
}

sub compiler_command {
  my ($mod) = @_;
  my $jco = opt("$mod.compiler", "$compiler_command");
  my $jc = opt("$jco.command");

  my $pedantic = opt("$mod.compiler.pedantic") || opt("compiler.pedantic");
  my $debug = opt("$mod.compiler.debug") || opt("compiler.debug");
  my $deprecation = opt("$mod.compiler.deprecation") || opt("compiler.deprecation");
  my $optimize = opt("$mod.compiler.optimize") || opt("compiler.optimize");
  my $args = opt("$mod.$jco.arguments") || opt("$jco.arguments");

  my $command = $jc;
  # pedantic only works for jikes
  $command .= " +P" if ($pedantic && $jco eq "jikes");
  $command .= " -g" if ($debug);
  $command .= " -deprecation" if ($deprecation);
  $command .= " -O" if ($optimize);
  $command .= " $args" if ($args ne "");

  return $command;
}
