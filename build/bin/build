#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#  Copyright 2001 Defense Advanced Research Projects
#  Agency (DARPA) and ALPINE (a BBN Technologies (BBN) and
#  Raytheon Systems Company (RSC) Consortium).
#  This software to be used only in accordance with the
#  COUGAAR licence agreement.
# </copyright>

# run a full release build

use Cwd;
use File::Copy;
use File::Path;
use File::Find;

$opt_file = "default.build";
@opt_overrides;

$verbose = 1;

sub parse_args {
  while ($#ARGV>=0) {
    $_ = shift @ARGV;
    if ( /^-o(.+)/) {
      push @opt_overrides, $1;
    } elsif (/^-r/) {
      $opt_r = shift @ARGV;
    } elsif (/^-D/) {
      $opt_D = shift @ARGV;
    } elsif ( /^-(.+)/) {
      foreach $c (split //, $1) {
	if ($c eq "h") {
	  usage();
	} elsif ($c eq "v") {
	  $verbose++;
	} elsif ($c eq "q") {
	  $verbose--;
	} elsif ($c eq "n") {
	  $opt_n = 1;
	} elsif ($c eq "Q") {
	  $nodoc = 1;
	} elsif ($c eq "S") {
	  $skip = 1;
	} elsif ($c eq "c") {
	  $checkoutP = 1;
	} else {
	  usage();
	}
      }
    } else {
      $opt_file = $_;
      usage() if ($#ARGV!=-1);
    }
  }
}


sub usage {
  print STDERR "Usage: build [options] ReleaseDescriptionFile\n";
  print STDERR "\t-S\tSkip checkout, rebuild from last try\n";
  print STDERR "\t-Q\tQuick build (no documentation)\n";
  print STDERR "\t-v\tbe verbose\n";
  print STDERR "\t-q\tbe quiet\n";
  print STDERR "\t-c\tcheckout cvs sources from head of tag rather than export from timestamp point\n";
  print STDERR "\t-okey=value\tset parameters on the command line\n";
  exit(1);
}

@modules;

%opts;
parse_args();
parse_config($opt_file);

#$javac_command = "jikes -g";
$javac_command = "javac -J-Xmx128m -J-Xms128m -g";
%javac_commands = (
		   "javac" => "javac -J-Xmx128m -J-Xms128m -g",
		   "jikes" => "jikes -g",
		   );
$rmic_command = "rmic -g -v1.2";

$java_command = "java";
$javac_command = opt("javac",$javac_command);
$java_command = opt("java", $java_command);
$javadoc_command = opt("javadoc", $javadoc_command);


#$javadoc_command = "/usr/local/java/jdk1.3/bin/javadoc -J-Xmx128m -J-Xms128m";
#$javadoc_command = "/usr/local/java/j2sdk1_3_0_02/bin/javadoc -J-Xmx128m -J-Xms128m";
#$javadoc_command = "javadoc -J-Xmx256m -J-Xms256m";

{
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  $rdate="$mon/$mday/$yr $hour:$min:$sec";
  # build time for build directory name
  $mon="0$mon" if ($mon<10);
  $mday="0$mday" if ($mday<10);
  $hour="0$hour" if($hour<10);
  $yr=$yr-2000;
  $yr="0$yr" if ($yr<10);
  $bdate="$yr$mon$mday$hour$min$sec";
}


# repository tag for build
if ($opt_r) {
  $rtag = $opt_r;
} else {
  $rtag = opt("tag.default");
  if (! $rtag) {
    $rtag = "HEAD";
  }
}

# build time
$rdate = $opt_D if ($opt_D);

# root of the build directory tree
$build_root = opt("build.root");
if (! $build_root) {
  my $foo = opt("product.name");
  die("Could not figure out build.root!\n") if (!$foo);
  $build_root = "/tmp/$foo";
}

if ($skip) {
  opendir D, $build_root;
  @alldirs = grep !/^\./, readdir D;
  closedir D;
  @alldirs = grep /[0-9]+/, @alldirs;
  @alldirs = sort @alldirs;
  @alldirs = reverse @alldirs;

  $bdate = $alldirs[0];
  print STDERR "Latest = $bdate\n";
}

# absolute path of directory we are building into
$build_dir = "$build_root/$bdate";

# just a copy of the enviroment variable (or maybe a command line option)
#$classpath = $ENV{CLASSPATH};
$classpath;
@sysjars;
# skip the classpath evar and use the sys.lib param
{
  @sysjars = findbypattern(opt("sys.lib"), "\.(jar|zip)\$");
  $classpath = join(":", @sysjars);
}


# classpath, possibly with rt.jar added for use by jikes
$augmented_classpath = $classpath;
@rtjars;
# hack for jikes until it is Java2 complient
if ( $javac_command =~ /jikes/ ) {
  my $javahome;
  if ( $java_command =~ /^(.+)\/bin\/java$/ ) {
    $javahome = $1;
  } else {
    open(JAVA, "which java|");
    my $line = <JAVA>;
    close(JAVA);
    if ($line =~ /(.*)\/bin\/java/) {
      $javahome = $1;
    } else {
      die("Cannot find java");
    }
  }
  if ($javahome) {
    $rtjar = "$javahome/jre/lib/rt.jar";
    @rtjars = ($rtjar);
    $augmented_classpath = "$augmented_classpath:$rtjar";
  }
}

# record start time for later measurement
$start_time = time;


# subdir containing all the sources
$srcdir = "$build_dir/src";

$product = opt("product.name");

$latest_dir = "$build_root/latest";

sub mkd {
  my($p) = @_;
  mkdir $p, 0777;
}


# create the build dirs
mkd "$build_root";
mkd $build_dir;
unlink "$latest_dir";
print "ln -s $build_dir $latest_dir\n" if $verbose;
symlink "$build_dir", "$latest_dir";
mkd $srcdir;
# libdir is where we store built jars
$libdir = "$build_dir/lib";
mkd $libdir;
# distdir is where we put end products
$distdir = "$build_dir/dist";
mkd $distdir;

chdir($distdir) || die("Couldn't chdir to $distdir");

# redirect streams to file
$errout = "$distdir/build.out";
open(SAVEOUT, ">&STDOUT");
open(SAVEERR, ">&STDERR");
#open(STDOUT, ">$errout");  # direct to file
open(STDOUT, "|tee $errout");  # tee to file
open(STDERR, ">&STDOUT");
select STDERR; $| = 1;		# unbuffered
select STDOUT; $| = 1;

print "Building $rtag at $rdate into $build_dir\n"  if $verbose;
print "Output is in $errout\n" if $verbose;

# Check out everything from CVS
&checkout if (!$skip);

# build the modules
&build;

# build unified source tree
&unify;

# build product.zip
&build_runtime;

# build product-support.zip
&build_3rdparty;

# build unified javadoc
&build_javadoc("unified", "$product-api") if (!$nodoc);

# find and report on errors/warnings
&find_errors();

add_md5("$build_dir/dist");

# get end time and report on elapsed time
{
  $end_time = time;
  $delta = $end_time - $start_time;
  $min = int ($delta/60);
  $sec = $delta%60;
  print "Elapsed time = $min minutes $sec seconds\n" if $verbose;
}

exit(0);

#
# the pass routines
#

# moby checkout
sub checkout {
  print "\nStarting checkout\n" if $verbose;
  mkd $srcdir;
  chdir ($srcdir) || die ("Couldn't chdir to $build_dir");

  foreach $mod (@modules) {
    my $repb = opt("repository.base");
    # if repository.base isn't set, get it from CVSROOT which should be set to
    # something like "/cvs/alp/cougaar"
    if (! $repb) {
      $repb = $ENV{'CVSROOT'};
      if ($repb) {
	$repb =~ s/\/cougaar$/\//;
      } else {
	die("Couldn't figure out repository.base!\n");
      }
    }

    my $rep = opt("$mod.repository");
    if (!$rep) {
      $rep = opt("repository.default");
      $rep = "cougaar" if (!$rep);
    }
    my $tag = opt("$mod.tag");
    $tag = $rtag if (!$tag);

    my $arg = "";
    $arg = "-Q";# if ($verbose<=1);
    my $rarg="";
    # special case for HEAD - bogon.
    $rarg = "-r $tag" if (! ($tag eq "HEAD"));
    if ($checkoutP) {
      # leave it in development mode
      mysystem ("cvs $arg -d '$repb$rep' checkout $rarg -d $mod $mod");
    } else {
      mysystem ("cvs $arg -d '$repb$rep' export $rarg -D '$rdate' -d $mod $mod");
    }
  }

  print "Checkout complete\n" if $verbose;
}

#
# moby build of modules
#

sub build {
  print "\nStarting building modules\n" if $verbose;

  build_module("build") || die("Compile of build module failed");

  foreach $mod (@modules) {
    build_module($mod) if (! ($mod eq "build"));
  }
  print "Finished building modules\n" if $verbose;
}


sub build_module {
  my ($mod) = @_;
  my $mysrc = "$srcdir/$mod/src";

  print "\nBuilding module $mod\n" if $verbose;

  my $tmplib = "/tmp/build-lib$$";
  mysystem("rm -rf $tmplib");

  my $cp = get_classpath($mod);

  if (-d $mysrc) {		# src exists
    print "Generating code for $mod\n" if $verbose;

    mkd $tmplib;
    # run code generators
    generate_code($mysrc, $cp);

    # compile sources
    print "Compiling $mod\n" if $verbose;
    chdir $mysrc;
    my $tmpfile = "/tmp/build.$$";
    mysystem("find . -name '*.java' -print>$tmpfile");
    my $jc = $javac_command;
    $jco = opt("$mod.javac");
    if ($jco) { $jc = $javac_commands{$jco}; }

    mysystem("$jc -d $tmplib -classpath $cp \@$tmpfile");

    # search for files/classes to rmic
    print "Searching for sources to RMIC\n" if $verbose;
    my(@rmicfiles)=sysPipe("find . -name '*Impl.java' -exec grep -l 'UnicastRemoteObject' {} \\;");
    if ($#rmicfiles>=0) {
      foreach $rf (@rmicfiles) {
	chomp $rf;
	$rf =~ /\.\/(.*)\.java/;
	$rf=$1;
	$rf =~ s/\//\./g;
	mysystem("$rmic_command -d $tmplib -classpath $tmplib:$cp $rf");
      }
    }

    print "Preparing jar for $mod\n" if $verbose;
    # copy non-java "sources" to tmplib
    add_module_files($mysrc, $tmplib);

    # create jar
    chdir ($tmplib);
    jar("$product/$mod runtime", $tmplib, "$libdir/$mod.jar", "$mysrc/manifest.mf");

    # clean up
    chdir ($mysrc);
    mysystem("rm -rf $tmplib $tmpfile");
  }

  # now create the product-module.zip file
  if (isPublic($mod)) {
    my $tmpdir = "/tmp/build-$mod.$$";
    mkd $tmpdir;
    my $tmpdist = "$tmpdir/$mod";
    mkd "$tmpdist";

    chdir "$srcdir/$mod";
    # bin,data,configs are now shipped as runtime parts.
    #my @shipped_subdirs = ("bin", "doc", "examples", "src", "data", "configs");
    my @shipped_subdirs = ("examples", "src");
    my @subdirs = ();
    foreach $sub (@shipped_subdirs) {
      if (-d "$srcdir/$mod/$sub") {
	push @subdirs, $sub ;
      }
    }
    my $subdirs = join(" ", @subdirs);
    mysystem("tar cf - $subdirs | (cd $tmpdist; tar xf -)");

    # only do javadoc if it is not part of the unified build
    if (! isUnified($mod)) {
      mkd "$tmpdist/api";
      javadoc($mod, $mysrc, "$tmpdist/api") if (!$nodoc);
    }

    zip("$product $module", $tmpdir, "$distdir/$mod-dev.zip");

    chdir($mysrc);
    mysystem("rm -rf $tmpdir");
  }

  print "Done building $mod\n" if $verbose;
  return 1;
}

# try to find exactly the set of jars needed based on dependencies, etc
#
sub get_classpath {
  local($mod) = @_;

  if ($mod eq "unified") {
    return get_unified_classpath();
  }
  # previously built jars
  my @buildjars = findbypattern($libdir, "\.jar\$");

  # current module's lib jars
  my @libjars = findbypattern("$srcdir/$mod/lib", "\.(jar|zip)\$");

  #put them together - module jars never take precedence
  my @alljars = (@buildjars, @sysjars, @libjars);

  # check the libjars carefully just in case someone is doing something stupid.
  {
    my @goodjars = (@buildjars, @sysjars);
    foreach $loclib (@libjars) {
      if ( ($loclib =~ /([^\/]+)\.(zip|jar)/) ) {
	my $match = $1;
	my @goods = grep /$1\.(zip|jar)$/, @goodjars;
	if ($#goods>=0) {
	  my $rc = mysystem("cmp $loclib $goods[0]");
	  print STDERR "Warning: Module $mod specifies $match as:\n\t$loclib\nwhich is also in:\n\t@goods\n\tmodule-local version will be ignored!\n";
	  if ($rc) {
	    print STDERR "Warning: $loclib and $goods[0] actually differ!\n";
	  } else {
	    print STDERR "The good news is that the $loclib and $goods[0] are the same.\n" if $verbose;
	  }
	}
      }
    }
  }

  # fill this up with required jars
  my @cp;

  foreach $dep (split /\s*,\s*/, opt("$mod.deps")) {
    my $jar = findjar($dep, @alljars);
    if ($jar eq "") {
      print "Warning: could not find $dep module for $mod\n";
    } else {
      push @cp, $jar;
    }
  }
  foreach $dep (split /\s*,\s*/, opt("$mod.jars")) {
    my $jar = findjar($dep, @alljars);
    if ($jar eq "") {
      print "Warning: could not find $dep jar for $mod\n";
    } else {
      push @cp, $jar;
    }
  }

  my @libs = (@cp, @rtjars);
  my $cp = join(":",@libs);
  return ".:$cp";
}

sub get_unified_classpath {
  my %member;
  my @cp;
  foreach $m (@modules) {
    if (isUnified($m)) {
      foreach $c (split(/:/,get_classpath($m))) {
	if (! ($member{$c})) {
	  $member{$c} = 1;
	  push @cp, $c;
	}
      }
    }
  }
  return join(":", @cp);
}

sub findjar {
  local($name, @jars) = @_;
  my $pat = "\/$name\.(jar|zip)\$";
  foreach $_ (@jars) {
    return $_ if (/$pat/);
  }
  "";
}

sub add_module_files {
  local ($mysrc, $tmplib) = @_;
  chdir $mysrc;
  my $files = join(" ", findbypattern(".", "\.(def|gif|jpg|png)\$"));
  if (! $files eq "") {
    mysystem("tar cf - $files | (cd $tmplib ; tar xf -)");
  }
}


# find all .def files and run the code generators on them
sub generate_code {
  my ($src, $cp) = @_;
  my @defs = findbypattern($src, "\.def\$");
  my $n = $#defs+1;
  for (@defs) {
    rundef($_, $cp);
  }
}

# code generate a single .def file
sub rundef {
  my ($path, $cp)=@_;
  open(DEF, "<$path");
  local($line);
  $line = <DEF>;
  local($rc)= -1;
  # if the first line is ";!generate: ..." then we'll use
  # it to build the def.
  if ( ($line =~ /\!generate:\s*(.*)$/) ) {
    $command = $1;	 
    # first word is the generator class
    @words = split /\s/, $command;

    # dirpath is the directory where the def file is
    @dirpath = split /\//, $path;
    pop @dirpath;
    $dirpath = join "/",@dirpath;

    # figure out the package name
    $class = $words[0];
    @pkgp = split /\./, $class;
    $pkgp = join "/",@pkgp;

    #print "Running $class\n" if $verbose;
    $args = join " ", @words[1..$#words];
    chdir($dirpath);
    $rc = mysystem("$java_command -classpath $libdir/build.jar:$cp $class $args $path");
  }
  close(DEF);
  return $rc;
}

#
# build the unified tree
#
sub unify {
  my $mod = "unified";
  my $mysrc = "$srcdir/$mod/src";

  print "\nBuilding unified sources\n" if $verbose;
  mkd "$srcdir/$mod";
  mkd "$mysrc";

  foreach $m (@modules) {
    if (isUnified($m)) {
      my $nbase = "$srcdir/$m";
      my $nsrc = "$nbase/src";
      chdir $nsrc;
      mysystem("tar cf - . | (cd $mysrc ; tar xf - )");
    }
  }
  print "Done building unified sources\n" if $verbose;
}

#
# build the runtime package
#
sub build_runtime {
  my $mod;
  my $tmpdir = "/tmp/runtime.$$";
  print "\nBuilding runtime dist\n" if $verbose;
  mkd $tmpdir;
  my $tl = "$tmpdir/lib";
  mkd $tl;
  foreach $mod (@modules) {
    if (-e "$build_dir/lib/$mod.jar") {
      mysystem("cp $build_dir/lib/$mod.jar $tl");
    }
    my $extraspec = opt("$mod.runtime");
    my $moddir = "$srcdir/$mod";
    chdir $moddir;
    if ($extraspec) {
      my @extras = split(/\s*,\s*/, $extraspec);
      foreach $extra (@extras) {
	mysystem("tar cf - $extra | (cd $tmpdir; tar xf -)");
      }
    }
    my @runtime_subdirs = ("bin", "data", "configs", "doc");
    foreach $rs (@runtime_subdirs) {
      # copy data dir
      if (-e "$moddir/$rs") {
	chdir "$moddir";
	mkd "$tmpdir/$mod";
	mkd "$tmpdir/$mod/$rs";
	mysystem("tar cf - $rs | (cd $tmpdir/$mod ; tar xf -)");
      }
    }
  }

  chdir $tmpdir;
  zip("$product runtime", $tmpdir, "$distdir/$product.zip");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building runtime dist\n" if $verbose;
}

# build the 3rdparty zip - mostly 3rd party jars.
sub build_3rdparty {
  my %member;
  my $mod;
  my $tmpdir = "/tmp/runtime.$$";
  print "\nBuilding 3rdparty dist\n" if $verbose;
  mkd $tmpdir;
  my $tl = "$tmpdir/sys";
  mkd $tl;

  # grab the modules (checked-in) jars
  foreach $mod (@modules) {
    my @libjars = findbypattern("$srcdir/$mod/lib", "\.(jar|zip)\$");
    my @alljars = (@sysjars, @libjars);	# prefer sysjars

    my @deps = ((split /\s*,\s*/, opt("$mod.jars")),
		(split /\s*,\s*/, opt("$mod.extras")));
    foreach $dep (@deps) {
      my $jar = findjar($dep, @alljars);
      if (!$jar) {
	my $foo = join(":",@alljars);
	print STDERR "Warning: could not find $dep in $foo\n";
      }
      if ($jar && ! ($member{$jar})) {
	  $member{$jar} = 1;
	  mysystem("cp $jar $tl");
	}
    }
  }

  chdir $tmpdir;
  zip("$product thirdparty jars", $tmpdir, "$distdir/$product-support.zip");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building 3rdparty dist\n" if $verbose;
}

sub build_javadoc {
  local($mod,$dest)=@_;

  $dest = "$mod-api" if ($dest eq "");

  print "\nBuilding javadoc of $mod\n" if $verbose;

  # generate javadoc from unified source
  my $tmpdir = "/tmp/javadoc.$$";
  mkd $tmpdir;
  mkd "$tmpdir/api";
  javadoc($mod, "$srcdir/$mod/src", "$tmpdir/api");

  chdir $tmpdir;
  zip("$product javadoc apis", $tmpdir, "$distdir/$dest.zip");
  chdir $build_dir;
  mysystem("rm -rf $tmpdir");
  print "Done building javadoc for $mod\n" if $verbose;
}

sub javadoc {
  local($mod, $src,$dst) = @_;
  my %pmap;
  chdir "$src";
  # find all the directories with packages and convert 
  open(LIST, "find . -name '*.java' -print|");
  while (<LIST>) {
    my $line = $_;
    my $p = rindex($line, '/') - 2;
    if ($p > 0) {
      $line = substr($line, 2, $p);
      $line =~ s/\//\./g;
      $pmap{$line}=1;
    }
  }
  close(LIST);
  my $pkgs = join(" ", keys %pmap);
  my $cp = get_classpath($mod);
  mysystem("$javadoc_command -classpath $cp -splitIndex -d $dst -sourcepath . $pkgs");
}

# zip up a directory, adding appropriate comments, sums, etc.
sub zip {
  local($comment, $dir, $dest) = @_;
  chdir $dir;
  add_info($comment, $dir);
  mysystem("zip -qr $dest *");
}

sub jar {
  local($comment, $dir, $dest, $mf) = @_;
  chdir $dir;
  add_info($comment, $dir);
  if (-r $mf) {
    mysystem("jar cmf $mf $dest *");
  } else {
    mysystem("jar cf $dest *");
  }
}

sub add_info {
  local($comment, $dir) = @_;
  open(OUT, ">$dir/version.txt");
  print OUT "COMMENT = $comment\n";
  print OUT "REPOSITORY_TAG = $rtag\n";
  print OUT "REPOSITORY_TIME = $rdate\n";
  local($sec, $min, $hour, $mday, $mon, $yr, $wday, $yday, $isdst) = localtime;
  $yr = $yr+1900;
  $mon++;
  $min="0$min" if ($min<10);
  $sec="0$sec" if ($sec<10);
  # default repository date
  my $d ="$mon/$mday/$yr $hour:$min:$sec";
  print OUT "ARCHIVE_TIME = $d\n";
  close OUT;
}

sub add_md5 {
  local($dir) = @_;
  chdir($dir);
  my @archives = findbypattern(".", "\.(jar|zip|tar|tgz)\$");
  my @list;
  foreach $a (@archives) {
    $a =~ s/^\.\///;
    push @list, $a;
  }
  my $list = join(" ", @list);
  mysystem("md5sum $list > md5sums.txt");
}

#
# here be utilities
#

sub mysystem {
  local($command)= @_;

  print STDERR "$command\n" if ($verbose>1);
  if ($pretend) {
    return 0;
  }

  if ($pid = fork ) {
    # parent
    waitpid $pid, 0;
    local($rc)= $?;
    # signal decoding from Perl5 manual
    $rc &= 0xffff;
    if ($rc != 0) {
      $sawerror++;
      if ($rc == 0xff00) {
	print STDERR "Command failed: $!\n";
      } elsif ($rc > 0x80) {
	$rc >>= 8;
	print STDERR "Completed with exit status of $rc\n";
      } else {
	print STDERR "Ran with ";
	if ($rc &  0x80) {
	  $rc &= 0x80;
	  print STDERR "coredump from ";
	}
	print STDERR "signal $rc\n";
      }
    }
  } elsif (defined $pid) {
    # child
    exec $command;
    print STDERR "$command: $!\n";
    exit(-1);
  } else {
    die "Couldn't run @_\n";
  }
}


sub sub_for_findbypattern {
   if (/^CVS$/) {
      $File::Find::prune = 1;
      return;
   }
   (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_));
   if (-d $_) {
      #      if (skipP($_)) {
      #       $File::Find::prune = 1;
      #       return;
      #      }
      ;
      } else {
         if (-f $_ && /$pat/) {
            push @stuff, $File::Find::name;
         }
      }
} 

sub findbypattern {
  local($dir, $pat) = @_;
  local(@stuff);
  @stuff = ();
  return @stuff if (! -e $dir);
#   local($code)= sub { 
#     if (/^CVS$/) {
#       $File::Find::prune = 1;
#       return;
#     }
#     (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_));
#     if (-d $_) {
# #      if (skipP($_)) {
# #	$File::Find::prune = 1;
# #	return;
# #      }
# ;
#     } else {
#       if (-f $_ && /$pat/) {
# 	push @stuff, $File::Find::name;
#       }
#     }
#   };
#   local(%ref);
#   $ref{"wanted"}=$code;
#   #&find(\%ref, $dir);
  find(\&sub_for_findbypattern, $dir);
  return @stuff;
}


sub sub_for_finddirs {
   if (/^CVS$/) {
      $File::Find::prune = 1;
   } else {
      if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -d $_ ) {
         push @stuff, $File::Find::name  if (!&skipP($File::Find::name));
      } 
   }
} 

sub finddirs {
  local($dir) = @_;
  local(@stuff);
  @stuff = ();
#   local($code)= sub { 
#     if (/^CVS$/) {
#       $File::Find::prune = 1;
#     } else {
#       if ((($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -d $_ ) {
# 	push @stuff, $File::Find::name 	if (!&skipP($File::Find::name));
#       }
#     }
#   };
#   local(%ref);
#   $ref{"wanted"}=$code;
#   #&find(\%ref, $dir);
  find(\&sub_for_finddirs, $dir);
  @stuff;
}

#parse the input file
sub parse_config {
  my ($file) = @_;

  open(STUFF,"<$file") || die("Could not open build script file '$file' for reading!\n");
  my $count = 0;
  my $leftover = "";
  while(<STUFF>) {
    chomp;
    $count++;

    s/\s*\#.*//; # drop comments immediately with leading whitespace

    # incorporate previous wrapped line text
    if (! ($leftover eq "")) {
      $_ = "$leftover$_";
      $leftover = "";
    }

    next if (/^\s*$/);		# empty line - handles empty comment line, too

    # detect line wrap directives
    if (/(.*)\\$/) {
      $leftover = $1;
      next;
    }

    print STDERR "$file (line $count): unknown format\n" if (! parseopt($_));
  }
  close(STUFF);

  foreach $_ (@opt_overrides) {
    print STDERR "Could not parse argument '-D$_'" if (! parseopt($_));
  }

  @modules = listify(opt("modules"));
  #print STDERR "modules = @modules\n";
}

sub parseopt {
  local ($_) = @_;
  if (/\s*(\S+)\s*=\s*(.+)\s*$/) {
    my $key = $1;
    my $val = $2;
    $opts{$key}=$val;
    return 1;
  } else {
    return 0;
  }
}

sub listify {
  my ($s) = @_;
  return split(/\s*,\s*/, $s);
}

sub opt {
  my ($key, $default) = @_;
  my ($value) = $opts{$key};
  if ($value eq "") {
    $value = $default;
  }
  return $value;
}

sub isPublic {
  my ($mod) = @_;
  # backward compatability
  return 0 if (opt("$mod.internal")); # it is non-public if defined as internal.

  return grep /$mod/, listify(opt("modules.public"));
}

sub isUnified {
  my ($mod) = @_;
  # backward compatability
  return 1 if (opt("$mod.unified"));

  return grep /$mod/, listify(opt("modules.unified"));
}

sub sysPipe {
  my ($command) = @_;
  open(P, "$command|");
  my (@lines) = <P>;
  close(P);
  return @lines;
}

sub find_errors {
  print "\nSearching for errors\n" if ($verbose);

  open(LOG, "<$errout");
  open(ERR, ">$distdir/errors.out");
  my ($ec) = 0;			# errors detected
  my ($wc) = 0;			# warnings detected
  my ($l) = 0;			# which line are we on?
  my ($cl) = -1;		# up to which line should we report on?
  while (<LOG>) {
    chomp;
    $nl = 0;
    # search for jikes warnings
    if (/Issued (\d+) semantic warning/) {
      $wc += $1;		# incr warning count
      $nl = max($nl,(5 * $1));	# 5 lines per warning
    }
    # search for jikes errors
    if (/Found (\d+) semantic error/) {
      $ec += $1;		# incr warning count
      $nl = max($nl,(5 * $1));	# 5 lines per warning
    }

    # search for javac (in 1.3) warnings/errors
    if (/\.java:(\d+):/) {
      if (/warning:/) {
	$wc++;
      } else {
	$ec++;
      }
      $nl = max($nl,5);
    }
    if (/^Note: /) {		# dep warnings
      $wc++;
      $nl = max($nl,1);
    }

    # search for build errors/warnings
    if (/^Warning:/) {
      $wc++;
      $nl = max($nl,1);
    }

    # do we need to advance the context pointer?
    my($x) = $l+$nl;
    $cl = $x if ($cl<$x);

    # copy the line to err if needed
    print ERR "$_\n" if ($l<$cl);
    $l++;
  }
  close(LOG);

  print ERR "\nTotal $ec errors and $wc warnings\n" if ($ec>0 || $wc>0);
  close(ERR);

  print STDERR "\nTotal $ec errors and $wc warnings\n" if ($ec>0 || $wc>0);
}

sub max {
  my($x,$y) = @_;
  ($x>$y)?$x:$y;
}
