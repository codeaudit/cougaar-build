#!/usr/bin/perl
# -*- Perl -*-

# <copyright>
#
#  Copyright 2001-2004 BBNT Solutions, LLC
#  under sponsorship of the Defense Advanced Research Projects
#  Agency (DARPA).
#
#  You can redistribute this software and/or modify it under the
#  terms of the Cougaar Open Source License as published on the
#  Cougaar Open Source Website (www.cougaar.org).
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# </copyright>

#
# generate an ANT script to checkout a cougaar tree from a build script
#
# Examples:
# 1. to create a top-level build.xml suitable for running the "checkout target" (or anything else):
# % genant -d targetdir default.build
# where targetdir is the name of the directory you want the build.xml to go into and default.build is the
# build configuration file (e.g. from build/data/default.build)
#
# 2. to create all the module default.xml buildfiles:
# % genant -d targetdir -c --p default.build
# -c says to (re)write the child buildfiles (default.xml).  Will also create missing
#  per-module build.xml files if they aren't already there.  add -f to replace
#  any existing module/build.xml files with the default skeletons.
# --p says to suppress creating the parent build.xml (wouldn't hurt, though)
#

$verbose = 0;  # set for debugging
$modulesTag = "modules";  # which property defines a list of all modules?
$genparent = 1;
$genchildren = 0;
$force = 0;

$outdir = ".";
@xvars;				# extra variable settings, specified by -D arguments
%props;

while ($#ARGV>=0) {
  my $arg = shift @ARGV;
  if ($arg eq "-h") {
    print STDOUT <<EOF
Usage: geneant [flags] configfile
flags are:
	-v	Print debugging output to STDERR
	-d dir	use the directory d as the output base (default is the current directory)
	-c	Generate the child buildfiles (--c turns them off - default is off)
	-f	Force overwrite of any files that we're willing to generate, particularly module/build.xml
	-p	Generate the toplevel build.xml (--p turns it off)
	-Dr=v	Set configuration variable r to value v.  Overrides anything in configfile.
		Any number of -D args are allowed.
	-h	print this help
The configfile is required.  If more than one is supplied, later ones may overwright earlier values
but -D arguments still take precedence.
EOF
      ;
    exit(-1);
  } elsif ($arg eq "-v") {
    $verbose++;
  } elsif ($arg eq "-f") {
    $force=1;
  } elsif ($arg eq "-c") {
    $genchildren=1;
  } elsif ($arg eq "--c") {
    $genchildren=0;
  } elsif ($arg eq "-p") {
    $genparent=1;
  } elsif ($arg eq "--p") {
    $genparent=0;
  } elsif ($arg eq "-d") {
    $outdir = shift @ARGV;
  } elsif ($arg =~ /^-D(.*)/) {
    push @xvars, $1;
  } else {
    if ($arg eq "-") {
      loadconfig(\*STDIN);
    } else {
      open CIN, "<$arg" || die "Couldn't open configuration file \"$arg\".";
      loadconfig(\*CIN);
      close(CIN);
    }
  }
}

foreach $x (@xvars) { parseExpr($x); }

if ($genparent) {
  if ($outdir eq "-") {
    generateParent(\*STDOUT);
  } else {
    my $f = "$outdir/build.xml";
    open COUT, ">$f" || die "Couldn't open \"$f\" for output";
    generateParent(\*COUT);
    close(COUT);
  }
}

if ($genchildren) {
  die "Illegal destination directory \"$outdir\" for writing child recipes" if ($outdir eq "-" || ! -d $outdir);

  generateChildren();
}

exit;

#
# parent recipes
#

sub generateParent {
  my ($out) = @_;
  print $out <<EOF
<?xml version="1.0"?>
<!-- Script for building $props{"product.name"} -->
<!-- WARNING  This was generated by build/bin/genant.  Any hand-edits will be lost! -->

<project name="$props{"product.name"}" default="help">
    <target name="initialize">
      <!-- Capture environment variables as \${env.VAR} -->
      <property environment="env"/>


      <!-- Set CIP property to first of -DCIP=, -DCOUGAAR_INSTALL_PATH=, \$CIP, \$COUGAAR_INSTALL_PATH, current directory -->
      <condition property="CIP" value="\${COUGAAR_INSTALL_PATH}">
	<isset property="COUGAAR_INSTALL_PATH"/>
      </condition>
      <condition property="CIP" value="\${env.COUGAAR_INSTALL_PATH}">
	<isset property="env.COUGAAR_INSTALL_PATH"/>
      </condition>
      <condition property="CIP" value="\${env.CIP}">
	<isset property="env.CIP"/>
      </condition>
      <property name="CIP" location="."/>

      <!-- Set the source tree directory base to the first of -Dsourcedir=, or \$CIP/src -->
      <property name="sourcedir" location="\${CIP}/src"/>

      <!-- Set the distribution target directory base to the first of -Dtargetdir=, or \$CIP/dist -->
      <property name="targetdir" location="\${CIP}/dist"/>

      <!-- Set the temporary file base directory to the first for -Dtmpdir=, or \$CIP/tmp -->
      <property name="tmpdir" location="\${CIP}/tmp"/>

      <!-- this is where module jars get copied during compile -->
      <property name="tmplib" value="\${tmpdir}/lib"/>

      <!-- make sure that directories exist -->
      <mkdir dir="\${sourcedir}"/>
      <mkdir dir="\${targetdir}"/>
      <mkdir dir="\${tmpdir}"/>
      <mkdir dir="\${tmplib}"/>
EOF
    ;

  generateProps($out);

  print $out <<EOF
    </target>

    <target name="help">
      <echo message="Valid targets are: checkout, compile, clean, test, pmd, doc"/>
    </target>

EOF
    ;
  generateCheckers($out);
  generateCheckoutTargets($out);
  generateSubTargets($out, "compile", \&generateCompileBody);
  generateSubTargets($out, "clean");
  generateSubTargets($out, "test");
  generateSubTargets($out, "pmd");
  generateSubTargets($out, "doc");
  generateSubTargets($out, "dist");  # TODO dist is actually different
  print $out <<EOF

    <!--
         Utilities
    -->

    <!-- invoke an ant target in a submodule's build.xml file -->
    <macrodef name="antmodule">
      <attribute name="module"/>
      <attribute name="target"/>
      <sequential>
        <ant antfile="\${sourcedir}/\@{module}/build.xml"
             dir="\${sourcedir}/\@{module}"
             target="\@{target}">
           <property name="target" value="\${tmpdir}"/>
        </ant>
      </sequential>
    </macrodef>

</project>
EOF
    ;
}

sub generateProps {
  my ($out) = @_;
  my @mods = allmods();

  print $out <<EOF
      <!-- these are properties for finding the sources -->

      <!-- cvs method, used in module.cvs.root -->
      <property name="cvs.method" value="ext"/>

      <!-- cvs rsh setting, if method is ext: -->
      <property name="cvs.rsh" value="ssh"/>

      <!-- default cvs host if method is ext: -->
      <property name="cvs.host" value="cougaar.org"/>

EOF
    ;

  foreach $mod (@mods) {
    my $modrep = get("$mod.repository");
    my $modmod = get("$mod.module");
    $modmod = $mod if ($modmod eq "");
    my $modtag = get("$mod.tag");
    $modtag = get("tag.default") if ($modtag eq "");
    $modtag = "HEAD" if ($modtag eq "");

    $modrep =~ s/:cougaar.org:/:\${cvs.host}:/;
    $modrep =~ s/^:ext:/:\${cvs.method}:/;

    print $out <<EOF

      <property name="$mod.cvs.root" value="$modrep"/>
      <property name="$mod.cvs.module" value="$modmod"/>
      <property name="$mod.cvs.tag" value="$modtag"/>
      <property name="$mod.cvs.rsh" value="\${cvs.rsh}"/>
EOF
      ;
  }

}

sub generateCheckers {
  my ($out) = @_;
  my @mods = allmods();

  my $alldeps = sprefix("checkout.",@mods);

  print $out <<EOF

    <!--
         Sub build.xml logic
    -->

    <target name="checkbuildxmls" depends="initialize">
       <!-- NOTE that this target should only be run when it is time to
            call into the module build.xmls.  This target is not called
            and these properties are not set during module build.xml generation -->
EOF
    ;
  foreach $mod (@mods) {
    print $out <<EOF
      <available property="$mod.has.build.xml" file="\${sourcedir}/$mod/build.xml"/>
EOF
      ;
  }

  print $out <<EOF
    </target>
EOF
    ;
}


sub generateCheckoutTargets {
  my ($out) = @_;
  my @mods = allmods();

  my $alldeps = sprefix("checkout.",@mods);

  print $out <<EOF

    <!--
         Checkout logic
    -->

    <target name="checkout" depends="initialize,$alldeps"/>

    <macrodef name="cvsco">
      <attribute name="module"/>
      <sequential>
        <cvs cvsRoot="\${\@{module}.cvs.root}"
             package="\${\@{module}.cvs.module}"
             tag="\${\@{module}.cvs.tag}"
             cvsRsh="\${\@{module}.cvs.rsh}"
             dest="\${sourcedir}">
          <commandline>
            <argument value="checkout"/>
            <argument value="-d"/>
            <argument value="\@{module}"/>
          </commandline>
        </cvs>
      </sequential>
    </macrodef>

EOF
    ;

  foreach $mod (@mods) {
    my @moddeps = getl("$mod.deps");
    my $md = sprefix("checkout.",@moddeps);
    $md = ",$md" if ($md ne "");
    print $out <<EOF
    <target name="checkout.$mod" depends="initialize$md">
      <cvsco module="$mod"/>
    </target>
EOF
      ;
  }
}


sub generateSubTargets {
  my ($out,$target,$bodygen) = @_;
  my @mods = allmods();
  my $alldeps = sprefix("$target.",@mods);

  print $out <<EOF

    <!--
         $target logic
    -->
    <target name="$target" depends="initialize,checkbuildxmls,$alldeps"/>
EOF
    ;

  foreach $mod (@mods) {
    my @moddeps = getl("$mod.deps");
    my $md = sprefix("$target.",@moddeps);
    $md = ",$md" if ($md ne "");
    print $out <<EOF
    <target name="$target.$mod" if="$mod.has.build.xml" depends="initialize,checkbuildxmls$md" >
      <antmodule module="$mod" target="$target"/>
EOF
      ;
    if ($bodygen) {
      &$bodygen($out,$mod);
    }
    print $out <<EOF
    </target>
EOF
      ;
  }
}

sub generateCompileBody {
  my ($out, $mod) = @_;

  print $out <<EOF
      <copy todir="\${tmplib}" flatten="yes">
        <fileset dir="\${sourcedir}/$mod">
          <include name="lib/*.jar"/>
          <include name="$mod.jar"/>
        </fileset>
      </copy>
EOF
    ;
}

#
# child ant recipes
#

sub generateChildren {
  my @mods = allmods();

  foreach $mod (@mods) {
    my $path = "$outdir/src/$mod";
    # check to make sure the directory is there
    system "mkdir -p $path" || die "Failed to make directory $path";

    # (re) generate the real builder.
    print STDERR "writing $path/default.xml\n" if $verbose;
    open COUT, ">$path/default.xml" || die "Couldn't open $path/default.xml for output";
    generateChildMain($mod, \*COUT);
    close(COUT);

    # generate a build.xml if we need one
    if ($force || ! -f "$d/build.xml") {
      print STDERR "writing $path/build.xml\n" if $verbose;
      open COUT, ">$path/build.xml" || die "Couldn't open $path/build.xml for output";
      generateChildDummy($mod, \*COUT);
      close(COUT);
    }

  }
}


sub generateChildMain {
  my ($mod, $out) = @_;

  my $prettyname = get("$mod.PrettyName"); $prettyname = $mod if ($prettyname eq "");
  my @deps = getl("$mod.deps");
  my @jars = getl("$mod.jars");
  my $compileJarlist = ssuffix(".jar",@deps, @jars);
  my @runtime = getl("$mod.runtime");
  my @extras = getl("$mod.extras");
  my $runJarlist = ssuffix(".jar", @deps, @jars, @runtime);

#  my $destlib = get("$mod.compiletime")?"clib":"lib";
  my $destlib = get("$mod.compiletime")?"lib":"lib";

  my $javahome = pget($mod, "java.home");
  my $javarv = pget($mod, "runtime.version", "1.5");
  my $javacargs = pget($mod, "javac.args");

  my $javacv = pget($mod, "compiler.version", "1.5");
  my $javacped = pget($mod, "compiler.pedantic", "off");
  my $javacdep = pget($mod, "compiler.deprecation", "on");
  my $javacopt = pget($mod, "compiler.optimize", "off");
  my $javacdebug = pget($mod, "compiler.debug", "on");

  print $out <<EOF
<?xml version="1.0"?>
<!-- Script for building $mod -->

<!-- NOTE: This script is machine-generated and will be overwritten by the cougaar build process.
     Do not hand-edit!  This file is imported by build.xml - any targets placed in build.xml
     will take precedence over these recipes.
  -->

<project name="Default $mod">
    <!-- property Setting -->
    <target name="real.initialize">
      <!-- the name of the module -->
      <property name="module" value="$mod"/>
      <!-- A prettier name for the module (e.g. might be capitalized) -->
      <property name="moduleUp" value="$prettyname"/>

      <property environment="env"/>
      <property name="parent.directory" location=".."/>
      <property name="this.directory" location="."/>

      <!-- where are we? -->
      <property name="MODSOURCE" location="." />
      <!-- load any module-local properties -->
      <property file="\${MODSOURCE}/module.properties" />

      <property name="JAVA_HOME" value="$javahome"/>

      <!-- figure out CIP (cougaar install path) -->
      <!-- Set CIP property to first of -DCIP=, -DCOUGAAR_INSTALL_PATH=, \$CIP, \$COUGAAR_INSTALL_PATH, parent directory -->
      <condition property="CIP" value="\${COUGAAR_INSTALL_PATH}">
	<isset property="COUGAAR_INSTALL_PATH"/>
      </condition>
      <condition property="CIP" value="\${env.COUGAAR_INSTALL_PATH}">
	<isset property="env.COUGAAR_INSTALL_PATH"/>
      </condition>
      <condition property="CIP" value="\${env.CIP}">
	<isset property="env.CIP"/>
      </condition>
      <property name="CIP" value="\${parent.directory}"/>

      <!-- Where does "dist" install to? either -DTARGETBASE, TARGETBASE evar, or CIP -->
      <condition property="TARGETBASE" value="\${env.TARGETBASE}">
        <isset property="env.TARGETBASE"/>
      </condition>
      <property name="TARGETBASE" value="\${CIP}"/>
      <property name="target" location="\${TARGETBASE}"/>

      <!-- load properties from TARGETBASE/global.properties if it exists -->
      <property file="\${TARGETBASE}/global.properties" />


      <!-- ================ Tool options ================ -->
      <!-- Individual users may choose to modify these settings. -->
      <!-- These values are only used if not already set by the
      module.properties or global.properties files. For all property
      values, the first setting wins. -->

      <!-- Include extra debug info in compilations -->
      <property name="java.path" value="\${JAVA_HOME}/bin/java"/>
      <property name="javac.path" value="\${JAVA_HOME}/bin/javac"/>
      <property name="javadoc.path" value="\${JAVA_HOME}/bin/javadoc"/>
      <property name="rmic.path" value="\${JAVA_HOME}/bin/rmic"/>

      <property name="build.compiler.debug" value="$javacdebug"/>
      <property name="build.compiler.deprecation" value="$javacdep"/>
      <property name="build.compiler.optimize" value="$javacopt"/>
      <property name="build.compiler.version" value="$javacv"/>
      <property name="build.runtime.version" value="$javarv"/>
      <property name="build.compiler.pedantic" value="$javacped"/>

      <!-- ================ Ant options ================ -->
      <!-- Keep the ant environment separate from the target environment -->
      <property name="build.sysclasspath" value="ignore"/>

      <!-- ================ Directories ================ -->

      <!-- TMP is a temporary location for compiling, zipping, etc -->
      <!-- Generated classfiles will go in TMP/classes, so that would often
      be the setting for COUGAAR_DEV_PATH in a developer environment -->
      <property name="TMP" value="\${MODSOURCE}/tmp" />

      <!-- Individuals should not need to modify below here. -->

      <!-- These are target base directories -->
      <!-- lib is for cougaar runtime jars -->
      <property name="target.lib" value="\${target}/lib" />
      <!-- sys is for 3rd party jars -->
      <property name="target.sys" value="\${target}/sys" />
      <!-- clib is for cougaar compile-time jars (codegen, etc) -->
      <property name="target.clib" value="\${target}/lib" />
      <!-- pmd is for PMD compile-time jars -->
      <property name="target.pmd" value="\${target}/pmd-1.5/lib" />
      <!-- dir is which of lib or clib the jar gets installed to -->
      <property name="target.dir" value="\${target}/$destlib"/>

      <!-- Single module Javadocs go in doc/api.  Not used if is.unified.javadoc -->
      <property name="javadoc.target" value="\${target}/\${module}/doc/api" />
      <!-- Target tree for modules which contribute to the unified javadoc  -->
      <property name="unified.target" value="\${target}/unified" />    

      <!-- These are source base directories -->
      <property name="src" value="\${MODSOURCE}/src" />

      <property name="local.lib" value="\${MODSOURCE}/lib" />
      <property name="regress" value="\${MODSOURCE}/regress" />
      <property name="examples" value="\${MODSOURCE}/examples" />
      <property name="bin" value="\${MODSOURCE}/bin" />
      <property name="doc" value="\${MODSOURCE}/doc" />
      <property name="data" value="\${MODSOURCE}/data" />
      <property name="configs" value="\${MODSOURCE}/configs" />
      <property name="dev" value="\${MODSOURCE}/dev" />

      <!-- These are temporary files and directories -->
      <property name="module.jar" value="\${TMP}/\${module}.jar"/>
      <property name="module.examples" value="\${TMP}/examples"/>
      <property name="module.classes" value="\${TMP}/classes"/>
      <property name="module.regress" value="\${TMP}/regress"/>
      <property name="module.api" value="\${TMP}/api"/>

      <!-- Set paths for use in creating zip files -->
      <property name="zipbase" value="\${TMP}/zip"/>

      <!-- where oh where oh where is java? Can be used to find tools.jar -->
      <!-- Note that JAVA_HOME must have been set in a .properties file -->
      <!-- Otherwise, the dynamically found version is used (usually finds the jre, ugh ). -->
      <!-- Also note that we're now using a checked-in version of tools.jar -->
      <property name="java.home" value="\${env.JAVA_HOME}"/>

      <!-- ================ Parameters ================ -->
      <!-- These properties are filled out by the autobuilder -->

      <!-- jarfiles required by this module, relative to various other paths -->
      <property name="compile.jarlist" value="$compileJarlist"/>

      <!-- Extra jars needed at run / unit-test time. -->
      <property name="run.jarlist" value="$runJarlist"/>

      <!-- ================ Classpaths ================ -->

      <!-- What are the dependencies of this module at compile time -->
      <path id="compile.classpath">
EOF
    ;
  foreach $j (@deps, @jars) {
    print $out "      <pathelement location=\"\${target}/lib/$j.jar\"/>\n";
  }
  print $out <<EOF
      </path>

      <!-- Build up classpath for junit.jar and classes when running tests -->
      <path id="junit.classpath">
	<path location="\${module.classes}" />
	<path location="\${module.regress}" />
	<filelist dir="\${target}/lib" files="\${run.jarlist}"/>
	<!-- junit.jar always comes from sys directory -->
	<path location="\${target.sys}/junit.jar"/>
      </path>

      <!-- Define path for doing javadoc: Basically, the runtime path -->
      <!-- tools.jar from the JDK must usually be in your JRE/lib
      directory, or you get ClassNotFoundExceptions "... while trying to
      register Taglet ..." -->
      <path id="javadoc.path">
	<path location="\${module.classes}" />
	<path location="\${module.regress}" />
	<filelist dir="\${target}/lib" files="\${run.jarlist}"/>
      </path>

      <!-- Define paths for doing codegen stuff -->
      <path id="codegen.path">
	<pathelement path="\${target.clib}/build.jar"/>
	<path refid="compile.classpath"/>
      </path>

      <!-- patterns -->
      <property name="extra.ps.jar.extras" value=""/>  <!-- override this to add to ps.jar.extras -->
      <!-- ps.jar.extras are sourcefiles which will be added to the jar -->
      <patternset id="ps.jar.extras" includes="\${extra.ps.jar.extras}">
	<include name="**/*.def"/>
	<include name="**/*.gif"/>
	<include name="**/*.html"/>
	<include name="**/*.htm"/>
	<include name="**/*.jpg"/>
	<include name="**/*.bmp"/>
	<include name="**/*.png"/>
	<include name="**/*.properties"/>
	<include name="**/*.xml"/>
	<include name="**/*.dtd"/>
	<include name="**/*.wav"/>
	<include name="**/*.au"/>
      </patternset>

      <property name="extra.ps.notsources" value=""/>  <!-- override to add to ps.notsources -->
      <patternset id="ps.notsources" includes="\${extra.ps.notsources}">
	<exclude name="**/CVS"/>
	<exclude name="**/*#"/>
	<exclude name="**/*~"/>
	<exclude name="**/*.class"/>
	<exclude name="**/*.flc"/>
	<exclude name="**/.cvsignore"/>
      </patternset>

    </target>

    <!-- ==================================================== -->
    <!-- Rebuild the Ant DTD, for use with XML editors. But note the warnings -->
    <!-- at http://ant.apache.org/manual/CoreTasks/antstructure.html -->
    <!-- ==================================================== -->
    <target name="build-ant-dtd" description="Rebuild the Ant DTD in CIP/build/data">
       <antstructure output="\${target}/build/data/ant-1.6.dtd"/>
    </target>

    <!-- ========================================================== -->
    <!-- Define dirs for copying files into for zipping -->
    <!-- All based on property zipbase -->
    <!-- ========================================================== -->
    <target name="set-zip-dirs" depends="initialize">
      <property name="zipdir.base" value="\${zipbase}/\${module}"/>
      <property name="zipdir.javadocs" value="\${zipbase}/\${module}/doc/api"/>
      <property name="zipdir.src" value="\${zipbase}/\${module}/src"/>
      <property name="zipdir.bin" value="\${zipbase}/\${module}/bin"/>
      <property name="zipdir.data" value="\${zipbase}/\${module}/data"/>
      <property name="zipdir.configs" value="\${zipbase}/\${module}/configs"/>
      <property name="zipdir.dev" value="\${zipbase}/\${module}/dev"/>
      <property name="zipdir.doc" value="\${zipbase}/\${module}/doc"/>
      <property name="zipdir.regress" value="\${zipbase}/\${module}/regress"/>
      <property name="zipdir.examples" value="\${zipbase}/\${module}/examples"/>
      <property name="zipdir.lib" value="\${zipbase}/lib"/>
      <property name="zipdir.clib" value="\${zipbase}/clib"/>
    </target>

    <!-- ========================================================== -->
    <!-- Test for presence of JUnit. Skip JUnit targets if not found. -->
    <!-- Also skip if there is no regress directory -->	
    <!-- ========================================================== -->
    <target name="junit" depends="prepare" if="has.regress">
      <available property="junit.present" classname="junit.framework.TestCase" classpathref="junit.classpath"/>
    </target>

    <!-- ========================================================== -->
    <!-- Test for presence of PMD. Skip PMD targets if not found. -->
    <!-- ========================================================== -->
    <target name="real.pmd" depends="prepare" if="has.pmd">
      <taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask">
        <classpath>
          <pathelement location="\${target.pmd}/jaxen-core-1.0-fcs.jar"/>
          <pathelement location="\${target.pmd}/pmd-1.5.jar"/>
          <pathelement location="\${target.pmd}/saxpath-1.0-fcs.jar"/>
          <pathelement location="\${target.pmd}/xercesImpl-2.0.2.jar"/>
          <pathelement location="\${target.pmd}/xmlParserAPIs-2.0.2.jar"/>
        </classpath>
      </taskdef>
      <pmd rulesetfiles="rulesets/basic.xml,rulesets/braces.xml,rulesets/codesize.xml,rulesets/controversial.xml,rulesets/coupling.xml,rulesets/design.xml,rulesets/favorites.xml,rulesets/finalizers.xml,rulesets/imports.xml,rulesets/javabeans.xml,rulesets/junit.xml,rulesets/naming.xml,rulesets/newrules.xml,rulesets/scratchpad.xml,rulesets/strictexception.xml,rulesets/strings.xml,rulesets/unusedcode.xml">
        <formatter type="html" toFile="\${module}_report.html"/>
        <fileset dir="\${src}" >
          <include name="**/*.java"/>
        </fileset>
      </pmd>
    </target>

    <!-- ========================================================== -->
    <!-- Run RMIC on built classes			                -->
    <!-- ========================================================== -->
    <!-- Mikes build script does: -->
    <!-- fileset of all files named *Impl.java that contain UnicastRemoteObject-->
    <!-- command is rmic -g -v1.2 -d destdir -classpath destdir:restofclasspath listoffiles -->
    <!-- remove dependency on prepare-rmic cause it is currently broken -->
    <target name="rmic-source" depends="prepare,prepare-rmic"
	    unless="rmic.notRequired" if="has.build">
      <rmic base="\${module.classes}" stubversion="1.2" verify="true"
	    debug="\${build.compiler.debug}"
	    includes="**/*Impl.class"> 
	<classpath>
	  <path location="\${module.classes}" />
	  <path refid="compile.classpath" />
	</classpath>
      </rmic>
    </target>

    <!-- ============================================================= -->
    <!-- Run the code generators                            	-->
    <!-- ============================================================= -->
    <target name="defrunner" depends="prepare-defrunner, prepare" unless="defrunner.notRequired" if="have.buildjar">
      <property name="genpath" refid="codegen.path"/>
      <apply executable="\${java.path}"
	     parallel="false"
	     failonerror="false" >
	<arg line="-classpath \${genpath} org.cougaar.tools.build.DefRunner" />
	<fileset dir="\${src}" >
	  <include name="**/*.def" />
	</fileset>
      </apply>
    </target>

    <!-- ============================================================= -->
    <!-- Clean up generated code                             	-->
    <!-- ============================================================= -->
    <target name="clean-gencode" depends="prepare, prepare-defrunner" description="Delete generated code" if="have.buildjar">
      <property name="genpath" refid="codegen.path"/>
      <apply executable="java"
	     parallel="false"
	     failonerror="false" >
	<arg line="-classpath \${genpath} org.cougaar.tools.build.DefCleaner" />
	<fileset dir="\${src}" >
	  <include name="**/*.gen" />
	</fileset>
      </apply>
    </target>
    
    <!-- ========================================================== -->
    <!-- Compiles the example Code			                -->
    <!-- ========================================================== -->	
    <target name="compile-examples" depends="prepare, compile" description="Compiles the example Code" if="has.examples">
      <mkdir dir="\${module.examples}" />
      <javac srcdir="\${examples}"
	     destdir="\${module.examples}"
	     includeAntRuntime="no"
	     source="\${build.compiler.version}"
	     target="\${build.runtime.version}"
	     debug="\${build.compiler.debug}"
	     optimize="\${build.compiler.optimize}"
	     deprecation="\${build.compiler.deprecation}"
             fork="yes"
             executable="\${javac.path}"
             >
	<classpath>
	  <path location="\${module.classes}" />
	  <path refid="compile.classpath" />
	</classpath>
      </javac>
      <!-- Copy any gifs and HTML help files over as well -->
      <copy todir="\${module.examples}" >
	<fileset dir="\${examples}">
	  <patternset refid="ps.jar.extras"/>
	</fileset>
      </copy>
    </target>

    <!-- ====================================================================== -->
    <!-- Clean up built example code     				    -->
    <!-- ====================================================================== -->	
    <target name="clean-examples" description="Delete compiled example code">
      <delete dir="\${module.examples}" />
    </target>

    <!-- ============================================================= -->
    <!-- Prepares all the build directories		               	   -->
    <!-- ============================================================= -->
    <target name="prepare" depends="initialize">

      <available property="has.examples" file="\${examples}"/>
      <available property="has.build" file="\${module.classes}"/>
      <available property="has.src" file="\${src}"/>
      <available property="has.bin" file="\${bin}"/>
      <available property="has.data" file="\${data}"/>
      <available property="has.configs" file="\${configs}"/>
      <available property="has.dev" file="\${dev}"/>
      <available property="has.doc" file="\${doc}"/>
      <available property="has.regress" file="\${regress}"/>
      <available property="has.pmd" file="\${target.pmd}"/>
      <available property="has.lib" file="\${local.lib}"/>

      <!-- Create the timestamp -->
      <tstamp/>
    </target>

    <target name="prepare-defrunner" depends="prepare"
	    if="has.src">

      <!-- Need build.jar -->
      <available property="have.buildjar" file="\${target.clib}/build.jar"/>

      <!-- Check if defrunner is required -->
      <uptodate property="defrunner.notRequired">
	<srcfiles dir="\${src}" includes="**/*.def"/>
	<!-- If file.gen newer than .def, don't rerun -->
	<mapper type="glob" from="*.def" to="*.gen"/>
	<!-- FIXME: even better: if above is true AND every file
	listed in .gen exists and is newer than .def, dont
	rerun -->
	<!-- Even better: parse out the \@generated tag and
	ensure that the date is more recent than on the listed .def file -->
      </uptodate>
    </target>

    <!-- See if files already RMICed, before re-RMICing -->
    <!-- FIXME: The identity mapper is not right!!! -->
    <!-- FIXME: In the meantime, do not use this!  -->
    <target name="prepare-rmic" depends="prepare" if="has.build">
      <uptodate property="rmic.notRequired">
	<srcfiles dir="\${module.classes}"
		  includes="**/*Impl.java"/>
	<!-- FIXME: What am I looking for here? -->
	<mapper type="identity"/>
      </uptodate>		
    </target>

    <!-- ========================================================== -->
    <!-- Compiles the Module Code			                -->
    <!-- ========================================================== -->	

    <!-- See if the jarfile needs recompiling -->
    <!-- Note that module-date.jar is not checked, just module.jar -->
    <!-- Also the property set here is _not_ currently used. -->
    <target name="check-sources" depends="prepare, defrunner" if="has.src">
      <uptodate property="jarfile.uptodate" targetfile="\${module.jar}">
	<srcfiles dir="\${src}" includes="**/*.java"/>
      </uptodate>
    </target>

    <!-- This really does the compilation. The above just calls this -->
    <target name="real.compile" depends="prepare, defrunner, check-sources, rmic-source" if="has.src">
      <mkdir dir="\${module.classes}" />
      <available property="has.build" file="\${module.classes}"/>
      <javac srcdir="\${src}" destdir="\${module.classes}"
	     source="\${build.compiler.version}"
             fork="yes"
             executable="\${javac.path}"
	     target="\${build.runtime.version}"
	     includeAntRuntime="no"
	     debug="\${build.compiler.debug}"
	     optimize="\${build.compiler.optimize}"
	     deprecation="\${build.compiler.deprecation}">
	<classpath>
	  <path refid="compile.classpath"/>
	</classpath>
      </javac>

      <!-- Copy any gifs and HTML help files over as well -->
      <copy todir="\${module.classes}" >
	<fileset dir="\${src}">
	  <patternset refid="ps.jar.extras"/>
	</fileset>
      </copy>

      <jar jarfile="\${module}.jar" basedir="\${module.classes}" />
    </target>

    <!-- FIXME: Should the if be has.build? -->
    <!-- Build the jar only for use in runtime zip -->
    <!-- Compare to the dist-module target -->
    <target name="jar.build" depends="compile, clean-tests, clean-examples" if="has.src">
      <!-- create the jarfile -->
      <jar jarfile="\${module.jar}" basedir="\${module.classes}" />
    </target>

    <!-- Install the Jar file in the target lib directory -->
    <target name="install.jar" depends="jar.build" if="has.build">
      <mkdir dir="\${target.dir}"/>
      <copy file="\${module.jar}" todir="\${target.dir}"/>
    </target>

    <!-- If there are any extra included jar files, install them -->
    <target name="install.lib" if="has.lib">
      <mkdir dir="\${target.sys}"/>
      <copy  todir="\${target.sys}">
	<fileset dir="\${local.lib}" includes="*.jar"/>
      </copy>
    </target>


    <!-- ========================================================== -->
    <!-- Compile EVERYTHING			                -->
    <!-- ========================================================== -->	
    <target name="compile-all" depends="initialize, compile, compile-tests, compile-examples" description="Compile all Module code plus examples and unit testing code" />

    <!-- ========================================================== -->
    <!-- Clean up all built code                    	-->
    <!-- ========================================================== -->
    <target name="real.clean" depends="initialize, clean-gencode" description="Delete compiled code">
      <delete dir="\${module.classes}" />
      <delete>
	<fileset dir="\${target.dir}" includes="**/\${module}.jar" />
      </delete>
    </target>

    <!-- ====================================================================== -->
    <!-- Compile regression test code     				          -->
    <!-- ====================================================================== -->	
    <target name="compile-tests" depends="prepare, junit, compile" description="Compile unit tests" if="junit.present"> 
      <mkdir dir="\${module.regress}" />
      <javac srcdir="\${regress}"
             destdir="\${module.regress}"
             source="\${build.compiler.version}"
	     target="\${build.runtime.version}"
             fork="yes"
             executable="\${javac.path}"
	     deprecation="\${build.compiler.deprecation}"
	     optimize="off"
	     debug="on">
	<classpath>
	  <path refid="junit.classpath"/>
	</classpath>
      </javac>
    </target>

    <!-- ====================================================================== -->
    <!-- Clean up built regress test code     				    -->
    <!-- ====================================================================== -->	
    <target name="clean-tests"
            description="Delete compiled junit code" 
            depends="initialize">
      <delete dir="\${module.regress}" />
    </target>

    <!-- ====================================================================== -->
    <!-- Run the regression tests     				          -->
    <!-- ====================================================================== -->
    <target name="real.test" depends="initialize,compile-all" if="junit.present" description="Run JUnit tests for this module">
      <junit printsummary="yes" fork="yes" dir="">
	<classpath>
	  <pathelement location="\${module.regress}" />
	  <path refid="junit.classpath" />
	</classpath>
	<formatter type="plain" />
	<batchtest>				
	  <fileset dir="\${module.regress}">
	    <include name="**/*Test.class" />
	  </fileset>  				
	</batchtest> 
	<!--			<test name="Regress" /> -->
      </junit>
    </target>

    <target name="test-module" depends="initialize,test" description="alias for test"/>

    <!-- ====================================================================== -->
    <!-- Create a Jar for the module     				          -->
    <!-- ====================================================================== -->	
    <target name="dist-module" depends="initialize, compile, clean-tests, clean-examples" description="Jars the module" if="has.build">
      <jar jarfile="\${target.lib}/\${module}-\${DSTAMP}.jar" basedir="\${module.classes}" />
      <exec dir="\${target.lib}" executable="ln" os="Linux">
	<arg line=" -s \${module}-\${DSTAMP}.jar \${module}.jar" />
      </exec>
    </target>
    

    <!-- ====================================================================== -->
    <!-- Clean up the JavaDocs for the module			          -->
    <!-- ====================================================================== -->	
    <target name="clean-docs" description="Delete javadocs" depends="initialize">
      <delete dir="\${javadoc.target}" />
    </target>

    <!-- ====================================================================== -->
    <!-- Generates the JavaDocs for the one module			          -->
    <!-- ====================================================================== -->	
    <target name="javadocs" depends="prepare, defrunner, clean-docs" description="Create javadocs for this module" if="has.src">
      <mkdir dir="\${javadoc.target}"/>
      <javadoc sourcepath="\${src}"
	       destdir="\${javadoc.target}"
	       author="true"
	       version="true"
	       use="true"
	       doclet="org.cougaar.tools.javadoc.CougaarDoclet"
	       docletpath="\${target.clib}/build.jar"
	       source="\${build.compiler.version}"
	       additionalparam="-breakiterator"
	       windowtitle="\${moduleUp} API"
	       doctitle="\${moduleUp} API"
               breakiterator="true"
	       bottom="Copyright &#169; 2006 by BBNT Solutions LLC, all rights reserved."
               executable="\${javadoc.path}">
	<classpath refid="javadoc.path" />
	<taglet name="org.cougaar.tools.javadoc.PropertyTaglet"
	       path="\${target.clib}/build.jar" />
	<taglet name="org.cougaar.tools.javadoc.NoteTaglet"
	       path="\${target.clib}/build.jar" />
	<taglet name="org.cougaar.tools.javadoc.ToDoTaglet"
	       path="\${target.clib}/build.jar" />
	<taglet name="org.cougaar.tools.javadoc.GeneratedTaglet"
	       path="\${target.clib}/build.jar" />
      </javadoc>
    </target>

    <!-- ====================================================================== -->
    <!-- Zip up the built JavaDocs				          -->
    <!-- ====================================================================== -->	
    <target name="zip-docs" depends="initialize, javadocs, set-zip-dirs, zip-copy-docs" description="Zip up built javadocs" if="has.src">
    <!-- FIXME: Put zip files someplace relative to target? -->
    <!-- FIXME: This fails if zipbase doesnt exist, ie if no javadocs -->
      <zip zipfile="../\${module}-api.zip" basedir="\${zipbase}" />
      <delete dir="\${zipdir.javadocs}"/>
    </target>
    <target name="zip-copy-docs" depends="initialize, javadocs, set-zip-dirs" if="has.src">
      <mkdir dir="\${zipdir.javadocs}"/>
      <copy todir="\${zipdir.javadocs}">
	<fileset dir="\${javadoc.target}" />
      </copy>
    </target>
    

    <!-- ====================================================================== -->
    <!-- Zip up the source: src, examples, regress, dev		          -->
    <!-- ====================================================================== -->	
    <!-- Note: perl script includes doc dir for non-unified modules -->
    <target name="zip-dev" depends="initialize, clean-gencode, set-zip-dirs,
    zip-prep, zip-copy-root-files, zip-copy-src, zip-copy-ex, zip-copy-dev, zip-copy-test"
	    description="Create -dev zip file">
    <!-- FIXME: Put zip files someplace relative to target? -->
    <!-- FIXME: This fails if no zipbase: If these dirs dont exist. -->
      <zip zipfile="../\${module}-dev.zip" basedir="\${zipbase}" />
      <delete dir="\${zipdir.src}"/>
      <delete dir="\${zipdir.examples}"/>
      <delete dir="\${zipdir.regress}"/>
      <delete dir="\${zipdir.dev}"/>
    </target>

    <target name="zip-prep">
      <delete dir="\${zipbase}"/>
    </target>

    <target name="zip-copy-root-files" depends="set-zip-dirs">
      <copy todir="\${zipdir.base}">
        <fileset dir="\${MODSOURCE}">
          <include name="build.xml"/>
          <!-- Others? -->
        </fileset>
      </copy>
    </target>
    <target name="zip-copy-src" depends="set-zip-dirs, prepare" if="has.src">
      <mkdir dir="\${zipdir.src}"/>
      <copy todir="\${zipdir.src}">
	<!-- skip CVS, #, ~, .class -->
	<fileset dir="\${src}">
	  <patternset refid="ps.notsources"/>
	</fileset>
      </copy>
    </target>

    <target name="zip-copy-ex" depends="set-zip-dirs, prepare" if="has.examples">
      <mkdir dir="\${zipdir.examples}"/>
      <copy todir="\${zipdir.examples}">
	<fileset dir="\${examples}">
	  <patternset refid="ps.notsources"/>
	</fileset>
      </copy>
    </target>
    <target name="zip-copy-test" depends="set-zip-dirs, junit" if="has.regress">
      <mkdir dir="\${zipdir.regress}"/>
      <copy todir="\${zipdir.regress}">
	<fileset dir="\${regress}">
	  <patternset refid="ps.notsources"/>
	</fileset>
      </copy>
    </target>
    <target name="zip-copy-dev" depends="prepare, set-zip-dirs" if="has.dev">
      <mkdir dir="\${zipdir.dev}"/>
      <copy todir="\${zipdir.dev}">
	<fileset dir="\${dev}">
	  <patternset refid="ps.notsources"/>
	</fileset>
      </copy>
    </target>

    <!-- ====================================================================== -->
    <!-- Zip up the runtime: bin, data, doc (less javadocs), plus the jar file -->
    <!-- ====================================================================== -->	
    <target name="zip-runtime" depends="clean-docs, compile, dist-module,
	    set-zip-dirs, zip-prep, zip-copy-bin, zip-copy-data, zip-copy-configs, zip-copy-doc" description="Create runtime zip file">
      <copy todir="\${zipdir.lib}">
      <!-- FIXME: This will get possibly multiple dated version of the
	jar? And get glmtrans when want just glm -->
	<fileset dir="\${target.lib}" includes="\${module}*.jar"/>
      </copy>
      <copy todir="\${zipdir.clib}">
	<fileset dir="\${target.clib}" includes="\${module}*.jar"/>
      </copy>
    <!-- FIXME: Put zip files someplace relative to target? -->
    <!-- FIXME: This fails if no zipbase: If these dirs dont exist. -->
		<!-- Ant zip target loses execute bit. Invoke zip
		directly therefore. Note OS dependency!  -->
		<!-- Note that Ant copy target also loses permissions,
		so you must call chmod after the copy below -->
      <zip zipfile="../\${module}.zip" basedir="\${zipbase}"/>
<!--      <exec dir="\${zipbase}" executable="zip">
	 <arg line="-qr ../\${module} ." />
      </exec> -->
      <delete dir="\${zipdir.lib}"/>
      <delete dir="\${zipdir.bin}"/>
      <delete dir="\${zipdir.data}"/>
      <delete dir="\${zipdir.configs}"/>
      <delete dir="\${zipdir.doc}"/>
    </target>
    <target name="zip-copy-bin" depends="prepare, set-zip-dirs" if="has.bin">
      <mkdir dir="\${zipdir.bin}"/>
      <copy todir="\${zipdir.bin}">
	<fileset dir="\${bin}" />
      </copy>
      <!-- copy drops execute bits -->
      <!-- Note this only works on Un*x platforms -->
<!--      <chmod dir="\${zipdir.bin}" perm="ugo+rx"
      includes="**/*.sh"/> -->
    </target>
    <target name="zip-copy-data" depends="prepare, set-zip-dirs" if="has.data">
      <mkdir dir="\${zipdir.data}"/>
      <copy todir="\${zipdir.data}">
	<fileset dir="\${data}" />
      </copy>
      <!-- copy drops execute bits -->
      <!-- Note this only works on Un*x platforms -->
<!--      <chmod dir="\${zipdir.data}" perm="ugo+rx"
      includes="**/*.sh"/> -->
    </target>
    <target name="zip-copy-configs" depends="prepare, set-zip-dirs" if="has.configs">
      <mkdir dir="\${zipdir.configs}"/>
      <copy todir="\${zipdir.configs}">
	<fileset dir="\${configs}" />
      </copy>
    </target>
    <target name="zip-copy-doc" depends="prepare, set-zip-dirs" if="has.doc">
      <mkdir dir="\${zipdir.doc}"/>
      <copy todir="\${zipdir.doc}">
	<fileset dir="\${doc}" />
      </copy>
    </target>


    <!-- top-level targets to make it easy to override in build.xml -->
    <target name="initialize" depends="real.initialize"/>
    <target name="compile" depends="real.compile"/>
    <target name="clean" depends="real.clean"/>
    <target name="test" depends="real.test"/>
    <target name="pmd" depends="real.pmd"/>
    <target name="doc" depends="real.doc"/>
    <target name="dist" depends="real.dist"/>

    <!-- These are the real targets that aren't above -->
    <target name="real.doc">
    </target>
    <target name="real.dist">
    </target>
    <target name="real.install" depends="initialize, install.jar, install.lib">
    </target>


</project>

EOF
}

sub generateChildDummy {
  my ($mod, $out) = @_;
  print $out <<EOF
<?xml version="1.0"?>
<!-- Script for building $mod -->

<!-- NOTE: This script may be hand-edited to override and extend the recipes defined by -->
<!-- the imported default.xml script in the same directory. You may even replace this   -->
<!-- file completely, ignoring default.xml (though default.xml will continue to be      -->
<!-- generated) as long as you make sure that the standard targets work correctly.      -->

<project name="$mod">
  <import file="default.xml"/>

  <!-- You make here define any new targets and override any targets defined by defaults.xml.
       The cleanest option is to redefine the top-level tasks (e.g. compile) to call the
       "real" targets along with whatever other processing you would like to do.  For instance

    <target name="compile" depends="before.compile,real.compile,after.compile"/>
    <target name="before.compile">
      <echo message="New stuff before we compile $module"/>
    </target>
    <target name="after.compile">
      <echo message="New stuff after we compile $module"/>
    </target>

    -->
</project>

EOF
    ;
}


#
# Utilities for handling config variables
#


sub getl {
  my $v = shift @_;
  split(/\s*,\s*/,$props{$v});
}

sub get {
  my $v = shift;
  $props{$v};
}

sub prefix {
  my $prefix = shift @_;
  my @result;
  for $_ (@_) {
    push @result, "$prefix$_";
  }
  @result;
}

sub suffix {
  my $suffix = shift @_;
  my @result;
  for $_ (@_) {
    push @result, "$_$suffix";
  }
  @result;
}

sub sprefix {
  join(",",prefix(@_));
}
sub ssuffix {
  join(",",suffix(@_));
}


sub loadconfig {
  my ($cin) = @_;

  $cont = "";
  $ln = -1;
  while (<$cin>) {
    chomp;
    $ln++;
    # prefix continuation line
    if ($cont ne "") {
      $_ = "$cont$_";
      $cont = "";
    }
    # drop comments
    s/#.*//;
    # drop excess whitespace
    s/^\s*//;
    s/\s*$//;
    # detect and postpone continuation
    if (/(.*)\\$/) {
      $cont = $1;
      next;
    }
    # skip empty lines
    next if ($_ eq "");

    parseExpr($_);
  }
}

sub parseExpr {
  my ($v) = @_;
  if ($v =~/([\w.]*)\s*=\s*(.*)/) {
    my $var = $1;
    my $val = $2;
    while ( $val =~ s/\$\{([\w.]*)\}/$props{$1}/ ) { }
    print STDERR "$var = $val\n" if $verbose;
    $props{$var}=$val;
  } else {
    print STDERR "Ignoring illegal configuration expression \"$v\"\n";
  }
}

sub allmods {
  my @mods = getl($modulesTag);
  my $sl = get("sys.lib");
  @mods=($1,@mods) if ($sl=~/^module:(.*)/);
  @mods;
}


sub pget {
  my ($mod, $key, $def) = @_;
  my $v = get($key); $v=$def if ($v eq "");
  my $mv = get("$mod.$key");
  if ($mv ne "") {
    if ($mv =~ /^+(.*)/) {
      return "$v$1";
    } else {
      return $mv;
    }
  } else {
    return $v;
  }
}
